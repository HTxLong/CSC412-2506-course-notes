{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CSC412/2506 Winter 2019: Probabilistic Learning and Reasoning Course Website Course Information Sheet When and Where Lectures: Tuesdays 15:00-17:00 in SS 2117 Tutorials: Thursday 13:00-14:00 in SS 2117","title":"About"},{"location":"#csc4122506-winter-2019-probabilistic-learning-and-reasoning","text":"Course Website Course Information Sheet","title":"CSC412/2506 Winter 2019: Probabilistic Learning and Reasoning"},{"location":"#when-and-where","text":"Lectures: Tuesdays 15:00-17:00 in SS 2117 Tutorials: Thursday 13:00-14:00 in SS 2117","title":"When and Where"},{"location":"lectures/week_1/","text":"Week 1: Introduction Assigned Reading Murphy: Chapters 1 and 2 Chapter 2 of David Mackay's textbook Overview Course information Overview of ML with examples Ungraded, anonymous background quiz Textbook and Resources There is no required textbook, but optional reading will be assigned each week Kevin Murphy (2012), Machine Learning: A Probabilistic Perspective . David MacKay (2003) Information Theory, Inference, and Learning Algorithms . The David MacKay textbook is recommended, although 100% of tested material come from class. In this course, lecture slides are more a supplement then main content. The most important stuff will be done on the blackboard, so it is important to come to class with pen and paper. Tutorial slides are relevant, but probably won't be tested. Assignments Assignments must be your own individual work. You can collaborate with up to 2 other students. You should name these people in your submission. Code should be readable . Make sure to put all plots and important results in your PDF submission. Related Courses CSC411: List of methods, (K-NN, Decision trees), more focus on computation STA302: Linear regression and classical stats ECE521: Similar material, more focus on computation STA414: Mostly same material, slightly more emphasis on theory than coding CSC321: Neural networks - about 30% overlap Stats vs Machine Learning Statisticians look at the data, consider the problem, and design a model we can understand. They Analyze methods to give guarantees Want to make few assumptions In machine learning , We only care about making good predictions! The basic idea is to learn a general procedure that works for lots of datasets. Often, there is no way around making assumptions, so we make our model large enough to hopefully learn something close to the truth. We can't use bounds in practice, so we evaluate and empirically choose model details. Sometimes, we end up with interpretable models anyways! In short, statistics starts with a model based on the data , machine learning aims to learn a model from the data. Types of Learning Unsupervised Learning: Given unlabeled data instances x_1 x_1 , x_2 x_2 , x_3 x_3 ... build a statistical model of x x , which can be used for making predictions, decisions. Supervised Learning: Given input-output pairs (x,y) (x,y) the goal is to predict correct output given a new input. Semi-supervised Learning: We are given only a limited amount of (x, y) (x, y) pairs, but lots of unlabeled x x 's Active learning and RL: Also get to choose actions that influence (x, y) (x, y) pairs, but lots of unlabeled x x \u2019s. future information + reward. Can just use basic decision theory. Note that these are all just special cases of estimating distributions from data: p(y | x) p(y | x) , p(x) p(x) , p(x, y) p(x, y) ! Finding Structure in Data With a big enough dataset, we can identify structure in the data. Take a large newswire corpus, for example. A simple model based on the word counts of webpages \\[P(x) = \\frac{1}{Z} \\sum_h \\exp [x^TWh]\\] could learn to discretize data into topics. In this case, our topics are our hidden (or latent ) variables. Note Sometimes latent variables correspond to aspects of physical reality, which could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are \"really there\", but hidden). Matrix Factorization Lets take a look at a specific example which uses matrix factorization for collaborative filtering . Part of the winning solution in the Netflix contest started with a Netflix dataset of 480,189 users, 17,770 movies and over 100 million ratings. The job was essentially to \"fill-in\" the missing information in a table that looked something like the following (hence the collaborative in collaborative filtering): After the modal was learned, it was clear that the latent representations it learned closley mapped what we might call genre : Multiple Kinds of Data in One Model My modeling the joint distribution of our data p(x, y) p(x, y) , we can incorporate multiple types of data under one model. In this example, our dataset consists of both images and text. Once the joint distribution is learned, we could provide a word and ask the model to sample from the learned distribution and return a picture (or vice versa!): Info Nguyen A, Dosovitskiy A, Yosinski J, Brox T, Clune J (2016). Synthesizing the preferred inputs for neurons in neural networks via deep generator networks. Advances in Neural Information Processing Systems 29 In fact, this is the key idea behind image captioning models: Latent Representations Once learned, latent representations of our data allow us to do some powerful things. For example, neural networks that are able to fill-in occuluded (or missing) portions of digital images: Info Pixel Recurrent Neural Networks. Aaron van den Oord, Nal Kalchbrenner, Koray Kavukcuoglu Because our latent space is really a vector space , we have access to all the mathematical operations that are defined on vectors, such as addition and subtraction . Furthermore, out latent representations (which themselves are just vector learned during model training) can be decoded into images (or words, or molecules, etc!). For example, if we were to learn latent representations of human faces, we could add and subtract these representations to create entirely new representations: Latent Representations of Structured Data Some data is structured in a way that is semantically meaningful. Put another way, there is a \"grammar\" to the data. Take the example of molecules representing pharmaceutical drugs. In this case, it is much more difficult to interpolate between two valid structures than it would be to interpolate between images of human faces, for example, because of the grammar of organic chemistry. Simplifying this point, two molecules that look extremely similar could in fact have wildly different behavior in the human body. The take-home point is that we need different methods for learning latent representations of structured data than unstructured data Course Themes This course will follow the broad theme of starting with a simple model and then adding to it. Example Linear regression and principal component analysis (PCA) are special cases of almost everything. A few \"lego bricks\" are enough to build most models (e.g. gaussians, categorical variables, linear transforms and neural networks). While the exact for of each distribution / function shouldn't mater much, your model should have a million parameters in it somewhere (the real world is messy!) Model checking is hard, but important. Learning algorithms are especially hard to debug. Computation Later assignments will involve a bit of programming. You can use whatever language you want, but python and numpy are recommended. For fitting and inference in high-dimensional models, gradient-based methods are basically the only game in town Lots of methods conflate model and fitting algorithm, we will try to separate these. ML as a Bag of Tricks Fast special cases Extensible family K-means Mixture of Gaussians Kernel Density Estimation Latent variable models SVMs Gaussian processes Boosting Deep neural nets Random Forests Bayesian neural nets K-Nearest Neighbours ?? Regularization as a Bag of Tricks Fast special cases Extensible family Early stopping Ensembling L2 Regularization Stochastic variational inference Gradient noise Dropout Expectation-Maximization A Language of Models Our goal will be to develop a language of models, a toolbox . For example, hidden Markov models, mixture of Gaussians, and logistic regression are all examples from a language of models. We will try to show a larger family, and point out common special cases. Using this language, you will be able to build you own custom models. In fact, we can talk about this family of models using very few ideas. Really, all we need are deep probabilistic latent-variable models and some decision theory . Russel and Norvig\u2019s parts of AI Extensible family Machine learning Natural language processing Knowledge representation Deep probabilistic latent-variable models + decision theory Automated reasoning Computer vision Robotics Advantages of probabilistic latent-variable models Data-efficient Learning Automatic regularization, can take advantage of more information. Model is aware what it doesn\u2019t know. E.g. after many cat images model updates get small. Showing a dog image for the first time would lead to large updates.\u0000 Compos-able models Models are built like lego blocks. E.g. you could incorporate a data corruption model. Handle Missing Corrupted Data Latent-variable models can easily handle missing and corrupted data, without the standard hacks of guessing missing values using averages. Predictive Uncertainty Necessary for decision-making. Bad models can confidently give us bad predictions. So can good modals! The key is to be able to express uncertainty. Conditional Predictions Be able to condition predictions can be powerful. E.g. if brexit happens, the value of the pound will fall. Active Learning What data would be expected to increase our confidence about a prediction. Disadvantages of Probabilistic Latent-variable Models Intractable integral over latent variables. Integrating over many dimensions is difficult and sometimes intractable. Probabilistic Graphical Models Vs. Neural Networks Imagine we had the following data we may try to model this data by fitting a mixture of Gaussians, as so which seems perfectly reasonable in this case. However, imagine instead we had the following data the use of a mixture model may not be appropriate in this case, as it fits the data poorly and reports too many clusters but a neural network who's job is to come up with a convincing distribution over where you can expect to see data does much better this brings us to a comparison of probabilistic graphical models and deep learning Probabilistic graphical models Deep learning \u2795 structured representations \u2796 neural net \"goo\" \u2795 priors and uncertainty \u2796 difficult parameterization \u2795 data and computational efficiency \u2796 can require lots of data \u2796 rigid assumptions may not fit \u2795 flexible \u2796 feature engineering \u2795 feature learning \u2796top-down inference \u2795 recognition networks \u2757 Left off on slide 35 The Unreasonable Easiness of Deep Learning The deep learning recipe involves defining an objective function (i.e. a probability of data given parameters) and optimizing the parameters to maximize the object. Gradients are computed automatically, you just need to define a model by some computation. Differentiable models Differentiable models, in general, follow these general principals 1. Model Distributions implicitly by a variable pushed through a deep net \\[y = f_{\\theta}(x) ; x \\sim \\mathcal N(0, I) \\] 2. Approximate intractable distribution by a tractable distribution parameterized by a deep net \\[p(y | x) = \\mathcal N(y | \\mu = f_{\\theta}(x), \\Sigma = g_{\\theta}(x))] ; x \\sim \\mathcal N(0, I) \\] 3. Optimize all parameters using stochastic gradient descent Modeling Idea Graphical models and neural networks have complimentary strengths, and can be combined. One such way to combine these models is by using structured prior distributions formulated as graphical models with highly nonlinear observation models implemented using neural networks . By pushing these structured prior distributions through a neural network we can get a model which takes exploits the best of both worlds This idea can be extended to supervised or unsupervised learning Learning Outcomes Know standard algorithms (bag of tricks), when to use them, and their limitations. For basic applications and baselines. Know main elements of language of deep probabilistic models (bag of bricks: distributions, expectations, latent variables, neural networks) and how to combine them. For custom applications + research. Know standard computational tools (Monte Carlo, Stochastic optimization, regularization, automatic differentiation). For fitting models. Tentative List of Topics Linear methods for regression + classification Bayesian linear regression Probabilistic Generative and Discriminative models - Regularization methods Stochastic Optimization and Neural Networks Graphical model notation and exact inference Mixture Models, Bayesian Networks Model Comparison and marginal likelihood Stochastic Variational Inference Time series and recurrent models Gaussian processes Variational Autoencoders Machine-learning-centric History of Probabilistic Models 1940s - 1960s Motivating probability and Bayesian inference 1980s - 2000s Bayesian machine learning with MCMC 1990s - 2000s Graphical models with exact inference 1990s - present Bayesian Nonparametrics with MCMC (Indian Buffet process, Chinese restaurant process) 1990s - 2000s Bayesian ML with mean-field variational inference 2000s - present Probabilistic Programming 2000s - 2013 Deep undirected graphical models (RBMs, pretraining) 2010s - present Stan - Bayesian Data Analysis with HMC 2000s - 2013 Autoencoders, denoising autoencoders 2000s - present Invertible density estimation 2013 - present Stochastic variational inference, variational autoencoders 2014 - present Generative adversarial nets, Real NVP, Pixelnet 2016 - present Lego-style deep generative models (attend, infer, repeat) Appendix Useful Resources Blog + tutorial on matrix factorization for movie recommendation. Glow an interactive OpenAI blog on Generative Models. It appears that a few of these slides were taken straight from this video. Summary of notation in probability and statistics . Glossary of Terms","title":"Week 1"},{"location":"lectures/week_1/#week-1-introduction","text":"","title":"Week 1: Introduction"},{"location":"lectures/week_1/#assigned-reading","text":"Murphy: Chapters 1 and 2 Chapter 2 of David Mackay's textbook","title":"Assigned Reading"},{"location":"lectures/week_1/#overview","text":"Course information Overview of ML with examples Ungraded, anonymous background quiz","title":"Overview"},{"location":"lectures/week_1/#textbook-and-resources","text":"There is no required textbook, but optional reading will be assigned each week Kevin Murphy (2012), Machine Learning: A Probabilistic Perspective . David MacKay (2003) Information Theory, Inference, and Learning Algorithms . The David MacKay textbook is recommended, although 100% of tested material come from class. In this course, lecture slides are more a supplement then main content. The most important stuff will be done on the blackboard, so it is important to come to class with pen and paper. Tutorial slides are relevant, but probably won't be tested.","title":"Textbook and Resources"},{"location":"lectures/week_1/#assignments","text":"Assignments must be your own individual work. You can collaborate with up to 2 other students. You should name these people in your submission. Code should be readable . Make sure to put all plots and important results in your PDF submission.","title":"Assignments"},{"location":"lectures/week_1/#related-courses","text":"CSC411: List of methods, (K-NN, Decision trees), more focus on computation STA302: Linear regression and classical stats ECE521: Similar material, more focus on computation STA414: Mostly same material, slightly more emphasis on theory than coding CSC321: Neural networks - about 30% overlap","title":"Related Courses"},{"location":"lectures/week_1/#stats-vs-machine-learning","text":"Statisticians look at the data, consider the problem, and design a model we can understand. They Analyze methods to give guarantees Want to make few assumptions In machine learning , We only care about making good predictions! The basic idea is to learn a general procedure that works for lots of datasets. Often, there is no way around making assumptions, so we make our model large enough to hopefully learn something close to the truth. We can't use bounds in practice, so we evaluate and empirically choose model details. Sometimes, we end up with interpretable models anyways! In short, statistics starts with a model based on the data , machine learning aims to learn a model from the data.","title":"Stats vs Machine Learning"},{"location":"lectures/week_1/#types-of-learning","text":"Unsupervised Learning: Given unlabeled data instances x_1 x_1 , x_2 x_2 , x_3 x_3 ... build a statistical model of x x , which can be used for making predictions, decisions. Supervised Learning: Given input-output pairs (x,y) (x,y) the goal is to predict correct output given a new input. Semi-supervised Learning: We are given only a limited amount of (x, y) (x, y) pairs, but lots of unlabeled x x 's Active learning and RL: Also get to choose actions that influence (x, y) (x, y) pairs, but lots of unlabeled x x \u2019s. future information + reward. Can just use basic decision theory. Note that these are all just special cases of estimating distributions from data: p(y | x) p(y | x) , p(x) p(x) , p(x, y) p(x, y) !","title":"Types of Learning"},{"location":"lectures/week_1/#finding-structure-in-data","text":"With a big enough dataset, we can identify structure in the data. Take a large newswire corpus, for example. A simple model based on the word counts of webpages \\[P(x) = \\frac{1}{Z} \\sum_h \\exp [x^TWh]\\] could learn to discretize data into topics. In this case, our topics are our hidden (or latent ) variables. Note Sometimes latent variables correspond to aspects of physical reality, which could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are \"really there\", but hidden).","title":"Finding Structure in Data"},{"location":"lectures/week_1/#matrix-factorization","text":"Lets take a look at a specific example which uses matrix factorization for collaborative filtering . Part of the winning solution in the Netflix contest started with a Netflix dataset of 480,189 users, 17,770 movies and over 100 million ratings. The job was essentially to \"fill-in\" the missing information in a table that looked something like the following (hence the collaborative in collaborative filtering): After the modal was learned, it was clear that the latent representations it learned closley mapped what we might call genre :","title":"Matrix Factorization"},{"location":"lectures/week_1/#multiple-kinds-of-data-in-one-model","text":"My modeling the joint distribution of our data p(x, y) p(x, y) , we can incorporate multiple types of data under one model. In this example, our dataset consists of both images and text. Once the joint distribution is learned, we could provide a word and ask the model to sample from the learned distribution and return a picture (or vice versa!): Info Nguyen A, Dosovitskiy A, Yosinski J, Brox T, Clune J (2016). Synthesizing the preferred inputs for neurons in neural networks via deep generator networks. Advances in Neural Information Processing Systems 29 In fact, this is the key idea behind image captioning models:","title":"Multiple Kinds of Data in One Model"},{"location":"lectures/week_1/#latent-representations","text":"Once learned, latent representations of our data allow us to do some powerful things. For example, neural networks that are able to fill-in occuluded (or missing) portions of digital images: Info Pixel Recurrent Neural Networks. Aaron van den Oord, Nal Kalchbrenner, Koray Kavukcuoglu Because our latent space is really a vector space , we have access to all the mathematical operations that are defined on vectors, such as addition and subtraction . Furthermore, out latent representations (which themselves are just vector learned during model training) can be decoded into images (or words, or molecules, etc!). For example, if we were to learn latent representations of human faces, we could add and subtract these representations to create entirely new representations:","title":"Latent Representations"},{"location":"lectures/week_1/#latent-representations-of-structured-data","text":"Some data is structured in a way that is semantically meaningful. Put another way, there is a \"grammar\" to the data. Take the example of molecules representing pharmaceutical drugs. In this case, it is much more difficult to interpolate between two valid structures than it would be to interpolate between images of human faces, for example, because of the grammar of organic chemistry. Simplifying this point, two molecules that look extremely similar could in fact have wildly different behavior in the human body. The take-home point is that we need different methods for learning latent representations of structured data than unstructured data","title":"Latent Representations of Structured Data"},{"location":"lectures/week_1/#course-themes","text":"This course will follow the broad theme of starting with a simple model and then adding to it. Example Linear regression and principal component analysis (PCA) are special cases of almost everything. A few \"lego bricks\" are enough to build most models (e.g. gaussians, categorical variables, linear transforms and neural networks). While the exact for of each distribution / function shouldn't mater much, your model should have a million parameters in it somewhere (the real world is messy!) Model checking is hard, but important. Learning algorithms are especially hard to debug.","title":"Course Themes"},{"location":"lectures/week_1/#computation","text":"Later assignments will involve a bit of programming. You can use whatever language you want, but python and numpy are recommended. For fitting and inference in high-dimensional models, gradient-based methods are basically the only game in town Lots of methods conflate model and fitting algorithm, we will try to separate these.","title":"Computation"},{"location":"lectures/week_1/#ml-as-a-bag-of-tricks","text":"Fast special cases Extensible family K-means Mixture of Gaussians Kernel Density Estimation Latent variable models SVMs Gaussian processes Boosting Deep neural nets Random Forests Bayesian neural nets K-Nearest Neighbours ??","title":"ML as a Bag of Tricks"},{"location":"lectures/week_1/#regularization-as-a-bag-of-tricks","text":"Fast special cases Extensible family Early stopping Ensembling L2 Regularization Stochastic variational inference Gradient noise Dropout Expectation-Maximization","title":"Regularization as a Bag of Tricks"},{"location":"lectures/week_1/#a-language-of-models","text":"Our goal will be to develop a language of models, a toolbox . For example, hidden Markov models, mixture of Gaussians, and logistic regression are all examples from a language of models. We will try to show a larger family, and point out common special cases. Using this language, you will be able to build you own custom models. In fact, we can talk about this family of models using very few ideas. Really, all we need are deep probabilistic latent-variable models and some decision theory . Russel and Norvig\u2019s parts of AI Extensible family Machine learning Natural language processing Knowledge representation Deep probabilistic latent-variable models + decision theory Automated reasoning Computer vision Robotics","title":"A Language of Models"},{"location":"lectures/week_1/#advantages-of-probabilistic-latent-variable-models","text":"Data-efficient Learning Automatic regularization, can take advantage of more information. Model is aware what it doesn\u2019t know. E.g. after many cat images model updates get small. Showing a dog image for the first time would lead to large updates.\u0000 Compos-able models Models are built like lego blocks. E.g. you could incorporate a data corruption model. Handle Missing Corrupted Data Latent-variable models can easily handle missing and corrupted data, without the standard hacks of guessing missing values using averages. Predictive Uncertainty Necessary for decision-making. Bad models can confidently give us bad predictions. So can good modals! The key is to be able to express uncertainty. Conditional Predictions Be able to condition predictions can be powerful. E.g. if brexit happens, the value of the pound will fall. Active Learning What data would be expected to increase our confidence about a prediction.","title":"Advantages of probabilistic latent-variable models"},{"location":"lectures/week_1/#disadvantages-of-probabilistic-latent-variable-models","text":"Intractable integral over latent variables. Integrating over many dimensions is difficult and sometimes intractable.","title":"Disadvantages of Probabilistic Latent-variable Models"},{"location":"lectures/week_1/#probabilistic-graphical-models-vs-neural-networks","text":"Imagine we had the following data we may try to model this data by fitting a mixture of Gaussians, as so which seems perfectly reasonable in this case. However, imagine instead we had the following data the use of a mixture model may not be appropriate in this case, as it fits the data poorly and reports too many clusters but a neural network who's job is to come up with a convincing distribution over where you can expect to see data does much better this brings us to a comparison of probabilistic graphical models and deep learning Probabilistic graphical models Deep learning \u2795 structured representations \u2796 neural net \"goo\" \u2795 priors and uncertainty \u2796 difficult parameterization \u2795 data and computational efficiency \u2796 can require lots of data \u2796 rigid assumptions may not fit \u2795 flexible \u2796 feature engineering \u2795 feature learning \u2796top-down inference \u2795 recognition networks \u2757 Left off on slide 35","title":"Probabilistic Graphical Models Vs. Neural Networks"},{"location":"lectures/week_1/#the-unreasonable-easiness-of-deep-learning","text":"The deep learning recipe involves defining an objective function (i.e. a probability of data given parameters) and optimizing the parameters to maximize the object. Gradients are computed automatically, you just need to define a model by some computation.","title":"The Unreasonable Easiness of Deep Learning"},{"location":"lectures/week_1/#differentiable-models","text":"Differentiable models, in general, follow these general principals 1. Model Distributions implicitly by a variable pushed through a deep net \\[y = f_{\\theta}(x) ; x \\sim \\mathcal N(0, I) \\] 2. Approximate intractable distribution by a tractable distribution parameterized by a deep net \\[p(y | x) = \\mathcal N(y | \\mu = f_{\\theta}(x), \\Sigma = g_{\\theta}(x))] ; x \\sim \\mathcal N(0, I) \\] 3. Optimize all parameters using stochastic gradient descent","title":"Differentiable models"},{"location":"lectures/week_1/#modeling-idea","text":"Graphical models and neural networks have complimentary strengths, and can be combined. One such way to combine these models is by using structured prior distributions formulated as graphical models with highly nonlinear observation models implemented using neural networks . By pushing these structured prior distributions through a neural network we can get a model which takes exploits the best of both worlds This idea can be extended to supervised or unsupervised learning","title":"Modeling Idea"},{"location":"lectures/week_1/#learning-outcomes","text":"Know standard algorithms (bag of tricks), when to use them, and their limitations. For basic applications and baselines. Know main elements of language of deep probabilistic models (bag of bricks: distributions, expectations, latent variables, neural networks) and how to combine them. For custom applications + research. Know standard computational tools (Monte Carlo, Stochastic optimization, regularization, automatic differentiation). For fitting models.","title":"Learning Outcomes"},{"location":"lectures/week_1/#tentative-list-of-topics","text":"Linear methods for regression + classification Bayesian linear regression Probabilistic Generative and Discriminative models - Regularization methods Stochastic Optimization and Neural Networks Graphical model notation and exact inference Mixture Models, Bayesian Networks Model Comparison and marginal likelihood Stochastic Variational Inference Time series and recurrent models Gaussian processes Variational Autoencoders","title":"Tentative List of Topics"},{"location":"lectures/week_1/#machine-learning-centric-history-of-probabilistic-models","text":"1940s - 1960s Motivating probability and Bayesian inference 1980s - 2000s Bayesian machine learning with MCMC 1990s - 2000s Graphical models with exact inference 1990s - present Bayesian Nonparametrics with MCMC (Indian Buffet process, Chinese restaurant process) 1990s - 2000s Bayesian ML with mean-field variational inference 2000s - present Probabilistic Programming 2000s - 2013 Deep undirected graphical models (RBMs, pretraining) 2010s - present Stan - Bayesian Data Analysis with HMC 2000s - 2013 Autoencoders, denoising autoencoders 2000s - present Invertible density estimation 2013 - present Stochastic variational inference, variational autoencoders 2014 - present Generative adversarial nets, Real NVP, Pixelnet 2016 - present Lego-style deep generative models (attend, infer, repeat)","title":"Machine-learning-centric History of Probabilistic Models"},{"location":"lectures/week_1/#appendix","text":"","title":"Appendix"},{"location":"lectures/week_1/#useful-resources","text":"Blog + tutorial on matrix factorization for movie recommendation. Glow an interactive OpenAI blog on Generative Models. It appears that a few of these slides were taken straight from this video. Summary of notation in probability and statistics .","title":"Useful Resources"},{"location":"lectures/week_1/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"lectures/week_2/","text":"Week 2: Introduction to Probabilistic Models Assigned Reading Murphy: Chapters 3, 4, 7-9 (excluding * sections) Chapter 3 of David Mackay's textbook Overview Overview of probabilistic models Sufficient statistics Likelihood Maximum likelihood estimation (MLE) Classification Overview of probabilistic models In general, we have variables that can be observed or unobserved ( latent variables are always unobserved!). The job of a probabilistic model is to relate the variables (observed or unobserved). More specifically, a probabilistic learns a joint probability distribution over variables, e.g. p(x_1, x_2, ..., x_N) p(x_1, x_2, ..., x_N) . Because the distributions are parameterized, learning is essentially joint density estimation . In a generative model , we assume our data is generated by some distribution then try to learn that distribution . The joint distribution (or joint density function) is the central object we use to define our model. From this perspective, we can think about the basic tasks we care about in machine learning (ML) as operations on joint distributions. One such task is classification Model : p(X, C) p(X, C) Task : p(C=c | x) = \\frac{p(c, x)}{p(x)} p(C=c | x) = \\frac{p(c, x)}{p(x)} where X X are our inputs, C C our classes and p(x) p(x) is the probability of our data (sometimes called the evidence ). p(x) p(x) can be re-written as the marginal probability p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} What happens if c c is never observed? Then we call this clustering . Clustering allows us to compute p(C=c|x) p(C=c|x) (\"the probability that the input belongs to some cluster\") even if c c is unobserved. If our inputs and classes are continuous, we call this regression p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} In general, if a variable is always observed, we may not want to model its density (regression / classification) if a variable is never observed (always unobserved) then we call it a hidden or latent variable and we may want to model its density (clustering, density estimation) In fact, we can mostly classify (no pun intended) the problems we care about into four types: Regression : p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} Classification : p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} Clustering : p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} Density Estimation : p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} Operations on Probabilistic Models The fundamental operations we will perform on a probabilistic modal are: Generate Data : For this you need to know how to sample from local models (directed) or how to do Gibbs or other sampling (undirected). Compute probabilities : When all nodes are either observed or marginalized the result is a single number which is the probability of the configuration. Inference : Compute expectations of some things given others which are observed or marginalized. Learning : Set the parameters of the joint distribution given some (partially) observed data to maximize the probability of seeing the data. Goals of a Probabilistic Model We want to build prediction systems automatically based on data, and as little as possible on expert information. In this course, we\u2019ll use probability to combine evidence from data and make predictions. We\u2019ll use graphical models as a visual shorthand language to express and reason about families of model assumptions, structures, dependencies and information flow, without specifying exact distributional forms or parameters. In this case learning means setting parameters of distributions given a model structure . Note \"Structure learning\" is also possible but we won\u2019t consider it now. More specifically, we want two things of our probabilistic model: Compact representation : we don't want parameters to scale poorly with dimensionality of the data. Efficient computation : we need to be able to compute the marginal and conditional probability from the join distribution efficiently. Multiple observations, Complete IID data A single observation of the data, X X is rarely useful on its own. Generally we have data including many observations, which creates a set of random variables: \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} To achieve our above-listed goals, we will make assumptions. Often, we assume the following: 1. Observations are independently and identically distributed (i.i.d) according to the joint distribution of the model. This reduces the computation of the conditional probability to the product of the individual probabilities of observations We don't always assume full independence. Sometimes, we assume only some level of independence between variables (e.g. var 3 depends on var 1 but not on var 2 ). 2. We observe all random variables in the domain on each observation (i.e. complete data, or fully observed model). We typically shade the nodes in a probabilistic graphical model to indicate they are observed. (Later we will work with unshaded nodes corresponding to missing data or latent variables.) Learning Parameters for a Distribution Lets take an example with discrete random variables . \\[ T: \\text{Temperature} ; t = \\text{\"hot\" or \"cold\"} \\] \\[ W: \\text{Weather} ; w = \\text{\"sunny\" or \"raining\"} \\] We know that \\[ P(T=h) = 0.40 \\] \\[ P(T=c) = 0.60 \\] \\[ P(W=s) = 0.70 \\] \\[ P(W=r) = 0.30 \\] and that these states define a valid probability distribution, so P(X) \\ge 0 ; \\sum_x P(x) = 1 P(X) \\ge 0 ; \\sum_x P(x) = 1 We could create a parameterized, probabilistic model, P(T, W) P(T, W) over the states \\[P(T | \\theta_T) ; \\theta_T = \\begin{bmatrix} 0.4 \\\\ 0.6 \\end{bmatrix}\\] \\[P(W | \\theta_W) ; \\theta_W = \\begin{bmatrix} 0.7 \\\\ 0.3 \\end{bmatrix}\\] Notice that \\theta_T \\theta_T and \\theta_W \\theta_W are the probability distributions of our random variables. Our parameters define the probability of the data explicitly and store it in a vector . We can represent the joint distribution P(T, W) P(T, W) , our model as: T W P h s 0.28 c r 0.18 h r 0.12 c s 0.42 from the joint distribution (which is again, essentially our model) we can compute the marginals \\[P(T=h) = \\sum_w P(T=h, W=w)\\] \\[ = 0.40\\] \\[P(T=c) = \\sum_w P(T=c, W=w)\\] \\[ = 0.60\\] \\[P(W=s) = \\sum_t P(W=s, T=t)\\] \\[ = 0.70\\] \\[P(W=r) = \\sum_t P(W=r, T=t)\\] \\[ = 0.30\\] and then we could ask questions about conditional probabilities, like P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 Why did we do this? The whole point of the above example was to show that from a probabilistic model, which itself is just a joint distribution represented as a matrix (or tensor), we can compute both the marginal and conditional probabilities. This will allow us to compute probabilities, generate data and perform inference. Joint Dimensionality Lets take our previous example and expand on it. Firstly, it is helpful to think of the joint distribution grid with k^n k^n squares, where n n is our number of variables and k k our states. For our running example, this means our joint distribution is parameterized by a 4 dimensional vector, containing the probabilities of seeing any pair of states. We could of course, add more random variables to our model. Imagine we add B B , for whether or not we bike into work and H H , for overall health , each with two states. The dimensionality of our parameters then becomes k^n = 2^4 k^n = 2^4 . It is important to note that our joint distribution will be computed based on the assumptions we make about independence between variables. For example, we could assume that while T T and W W are independent from one another, H H is dependent on both T T and W W as well as B B . From the chain rule, we get P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) Likelihood function So far, we have focused on the (log) probability function p(x|\\theta) p(x|\\theta) which assigns a probability (density) to any joint configuration of variables x x given fixed parameters \\theta \\theta . But our goal is to learn theta theta , which we do not start with and which is not fixed . This is the opposite of how we want to think. Really, we have some fixed data and we want to find parameters \\theta \\theta which maximize the likelihood of that data. Note We are asking \"given x x , how do I choose \\theta \\theta \". To do this, we define some function \\ell(\\theta ; x) = \\log p(x|\\theta) \\ell(\\theta ; x) = \\log p(x|\\theta) which we call the log likelihood function . Note The likelihood function is essentially a notational trick in order to make it easy to talk about our data as a function of our parameters. The process of learning is choosing \\theta \\theta to maximize some cost of loss function, L(\\theta) L(\\theta) which includes \\ell (\\theta) \\ell (\\theta) . This can be done in a couple of ways, including: Maximum likelihood estimation : L(\\theta) = \\ell (\\theta; \\mathcal D) L(\\theta) = \\ell (\\theta; \\mathcal D) Maximum a posteriori : L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) Maximum likelihood estimation The basic idea behind maximum likelihood estimation (MLE) is to pick values for our parameters which were most likely to have generated the data we saw \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) Note MLE is commonly used in statistics, and often leads to \"intuitive\", \"appealing\" or \"natural\" estimators. For IID data \\[p(\\mathcal D | \\theta) = \\prod_m p(x^{(m)} | \\theta)\\] \\[\\ell (\\theta ; D | \\theta) = \\sum_m log p(x^{(m)} | \\theta)\\] Note The IDD assumption turns the log likelihood into a sum, making the derivative easy to compute. Sufficient statistics A statistic is a (possibly vector valued) deterministic function of a (set of) random variable(s). A sufficient statistic is a statistic that conveys exactly the same information about the data generating process that created that data as the entire data itself. In other words, once we know the sufficient statistic, T(x) T(x) , then our inferences are the same as would be obtained from our entire data. More formally, we say that T(X) T(X) is a sufficient statistic for X X if T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta Put another way P(\\theta | T(X)) = P(\\theta | X) P(\\theta | T(X)) = P(\\theta | X) Note Why is the useful? Well, if we have a particular large data sample, a lot of the data may be redundant. If we knew the sufficient statistic for that sample, we could use it in place of the full data sample. Equivalently (by the Neyman factorization theorem) we can write P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) An example is the exponential family p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} Sufficient statistics example: Bernoulli Trials Let us take the example of flipping a fair coin. This process that generates our data is can be modeled as a Bernoulli distribution X \\backsim \\text{Ber}(\\theta) X \\backsim \\text{Ber}(\\theta) where X X is a random variable and x_i x_i represents the result of the ith coin flip \\[x_i = 0 \\text{ , if tails}\\] \\[x_i = 1 \\text{ , if heads}\\] the likelihood (assuming independence between flips of the coin) is \\[L = \\prod_{i=1}^N \\theta^{x_i}(1-\\theta)^{1-x_i}\\] \\[= \\theta^{\\sum_{i=1}^N x_i}(1-\\theta)^{N-\\sum_{i=1}^N x_i}\\] \\[= T(x)(1-\\theta)^{N-T(X)}\\] So we notice here that our likelihood depends on \\sum_{i=1}^N x_i \\sum_{i=1}^N x_i . In other words, our data only enters the likelihood in this particular form. This tells us that if we know this summary statistic, which we will call T(x) = \\sum_{i=1}^N x_i T(x) = \\sum_{i=1}^N x_i then essentially we know everything that is useful from our sample to do inference. To perform inference with T(x) T(x) , we define the log likelihood \\[\\ell(\\theta ; X) = \\log p(X | \\theta)\\] \\[ = T(X) \\log \\theta - (N - T(X)) \\log(1-\\theta) \\] then we take the derivative and set it to 0 to find the maximum \\frac{\\partial \\ell}{\\partial \\theta} = 0 = \\frac{T(X)}{N} \\frac{\\partial \\ell}{\\partial \\theta} = 0 = \\frac{T(X)}{N} This is our maximum likelihood estimation of the parameters \\theta \\theta , \\theta^{\\star}_{ML} \\theta^{\\star}_{ML} . Note See Lecture 2 slides 10-13 for more examples. Summary of Probabilistic Models In general, learning the parameters of a probabilistic model depends on whether our variables are observed or partially observed, continuous or discrete Continuous Discrete Fully observed variables Bespoke estimates from calculus Normalized counts Partially observed variables Variational inference, recognition networks, MCMC Message passing, variable elimination, junction tree Appendix Useful Resources Helpful video on sufficient statistics. Glossary of Terms","title":"Week 2"},{"location":"lectures/week_2/#week-2-introduction-to-probabilistic-models","text":"","title":"Week 2: Introduction to Probabilistic Models"},{"location":"lectures/week_2/#assigned-reading","text":"Murphy: Chapters 3, 4, 7-9 (excluding * sections) Chapter 3 of David Mackay's textbook","title":"Assigned Reading"},{"location":"lectures/week_2/#overview","text":"Overview of probabilistic models Sufficient statistics Likelihood Maximum likelihood estimation (MLE) Classification","title":"Overview"},{"location":"lectures/week_2/#overview-of-probabilistic-models","text":"In general, we have variables that can be observed or unobserved ( latent variables are always unobserved!). The job of a probabilistic model is to relate the variables (observed or unobserved). More specifically, a probabilistic learns a joint probability distribution over variables, e.g. p(x_1, x_2, ..., x_N) p(x_1, x_2, ..., x_N) . Because the distributions are parameterized, learning is essentially joint density estimation . In a generative model , we assume our data is generated by some distribution then try to learn that distribution . The joint distribution (or joint density function) is the central object we use to define our model. From this perspective, we can think about the basic tasks we care about in machine learning (ML) as operations on joint distributions. One such task is classification Model : p(X, C) p(X, C) Task : p(C=c | x) = \\frac{p(c, x)}{p(x)} p(C=c | x) = \\frac{p(c, x)}{p(x)} where X X are our inputs, C C our classes and p(x) p(x) is the probability of our data (sometimes called the evidence ). p(x) p(x) can be re-written as the marginal probability p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} What happens if c c is never observed? Then we call this clustering . Clustering allows us to compute p(C=c|x) p(C=c|x) (\"the probability that the input belongs to some cluster\") even if c c is unobserved. If our inputs and classes are continuous, we call this regression p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} In general, if a variable is always observed, we may not want to model its density (regression / classification) if a variable is never observed (always unobserved) then we call it a hidden or latent variable and we may want to model its density (clustering, density estimation) In fact, we can mostly classify (no pun intended) the problems we care about into four types: Regression : p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} Classification : p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} Clustering : p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} Density Estimation : p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved}","title":"Overview of probabilistic models"},{"location":"lectures/week_2/#operations-on-probabilistic-models","text":"The fundamental operations we will perform on a probabilistic modal are: Generate Data : For this you need to know how to sample from local models (directed) or how to do Gibbs or other sampling (undirected). Compute probabilities : When all nodes are either observed or marginalized the result is a single number which is the probability of the configuration. Inference : Compute expectations of some things given others which are observed or marginalized. Learning : Set the parameters of the joint distribution given some (partially) observed data to maximize the probability of seeing the data.","title":"Operations on Probabilistic Models"},{"location":"lectures/week_2/#goals-of-a-probabilistic-model","text":"We want to build prediction systems automatically based on data, and as little as possible on expert information. In this course, we\u2019ll use probability to combine evidence from data and make predictions. We\u2019ll use graphical models as a visual shorthand language to express and reason about families of model assumptions, structures, dependencies and information flow, without specifying exact distributional forms or parameters. In this case learning means setting parameters of distributions given a model structure . Note \"Structure learning\" is also possible but we won\u2019t consider it now. More specifically, we want two things of our probabilistic model: Compact representation : we don't want parameters to scale poorly with dimensionality of the data. Efficient computation : we need to be able to compute the marginal and conditional probability from the join distribution efficiently.","title":"Goals of a Probabilistic Model"},{"location":"lectures/week_2/#multiple-observations-complete-iid-data","text":"A single observation of the data, X X is rarely useful on its own. Generally we have data including many observations, which creates a set of random variables: \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} To achieve our above-listed goals, we will make assumptions. Often, we assume the following: 1. Observations are independently and identically distributed (i.i.d) according to the joint distribution of the model. This reduces the computation of the conditional probability to the product of the individual probabilities of observations We don't always assume full independence. Sometimes, we assume only some level of independence between variables (e.g. var 3 depends on var 1 but not on var 2 ). 2. We observe all random variables in the domain on each observation (i.e. complete data, or fully observed model). We typically shade the nodes in a probabilistic graphical model to indicate they are observed. (Later we will work with unshaded nodes corresponding to missing data or latent variables.)","title":"Multiple observations, Complete IID data"},{"location":"lectures/week_2/#learning-parameters-for-a-distribution","text":"Lets take an example with discrete random variables . \\[ T: \\text{Temperature} ; t = \\text{\"hot\" or \"cold\"} \\] \\[ W: \\text{Weather} ; w = \\text{\"sunny\" or \"raining\"} \\] We know that \\[ P(T=h) = 0.40 \\] \\[ P(T=c) = 0.60 \\] \\[ P(W=s) = 0.70 \\] \\[ P(W=r) = 0.30 \\] and that these states define a valid probability distribution, so P(X) \\ge 0 ; \\sum_x P(x) = 1 P(X) \\ge 0 ; \\sum_x P(x) = 1 We could create a parameterized, probabilistic model, P(T, W) P(T, W) over the states \\[P(T | \\theta_T) ; \\theta_T = \\begin{bmatrix} 0.4 \\\\ 0.6 \\end{bmatrix}\\] \\[P(W | \\theta_W) ; \\theta_W = \\begin{bmatrix} 0.7 \\\\ 0.3 \\end{bmatrix}\\] Notice that \\theta_T \\theta_T and \\theta_W \\theta_W are the probability distributions of our random variables. Our parameters define the probability of the data explicitly and store it in a vector . We can represent the joint distribution P(T, W) P(T, W) , our model as: T W P h s 0.28 c r 0.18 h r 0.12 c s 0.42 from the joint distribution (which is again, essentially our model) we can compute the marginals \\[P(T=h) = \\sum_w P(T=h, W=w)\\] \\[ = 0.40\\] \\[P(T=c) = \\sum_w P(T=c, W=w)\\] \\[ = 0.60\\] \\[P(W=s) = \\sum_t P(W=s, T=t)\\] \\[ = 0.70\\] \\[P(W=r) = \\sum_t P(W=r, T=t)\\] \\[ = 0.30\\] and then we could ask questions about conditional probabilities, like P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66","title":"Learning Parameters for a Distribution"},{"location":"lectures/week_2/#why-did-we-do-this","text":"The whole point of the above example was to show that from a probabilistic model, which itself is just a joint distribution represented as a matrix (or tensor), we can compute both the marginal and conditional probabilities. This will allow us to compute probabilities, generate data and perform inference.","title":"Why did we do this?"},{"location":"lectures/week_2/#joint-dimensionality","text":"Lets take our previous example and expand on it. Firstly, it is helpful to think of the joint distribution grid with k^n k^n squares, where n n is our number of variables and k k our states. For our running example, this means our joint distribution is parameterized by a 4 dimensional vector, containing the probabilities of seeing any pair of states. We could of course, add more random variables to our model. Imagine we add B B , for whether or not we bike into work and H H , for overall health , each with two states. The dimensionality of our parameters then becomes k^n = 2^4 k^n = 2^4 . It is important to note that our joint distribution will be computed based on the assumptions we make about independence between variables. For example, we could assume that while T T and W W are independent from one another, H H is dependent on both T T and W W as well as B B . From the chain rule, we get P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B)","title":"Joint Dimensionality"},{"location":"lectures/week_2/#likelihood-function","text":"So far, we have focused on the (log) probability function p(x|\\theta) p(x|\\theta) which assigns a probability (density) to any joint configuration of variables x x given fixed parameters \\theta \\theta . But our goal is to learn theta theta , which we do not start with and which is not fixed . This is the opposite of how we want to think. Really, we have some fixed data and we want to find parameters \\theta \\theta which maximize the likelihood of that data. Note We are asking \"given x x , how do I choose \\theta \\theta \". To do this, we define some function \\ell(\\theta ; x) = \\log p(x|\\theta) \\ell(\\theta ; x) = \\log p(x|\\theta) which we call the log likelihood function . Note The likelihood function is essentially a notational trick in order to make it easy to talk about our data as a function of our parameters. The process of learning is choosing \\theta \\theta to maximize some cost of loss function, L(\\theta) L(\\theta) which includes \\ell (\\theta) \\ell (\\theta) . This can be done in a couple of ways, including: Maximum likelihood estimation : L(\\theta) = \\ell (\\theta; \\mathcal D) L(\\theta) = \\ell (\\theta; \\mathcal D) Maximum a posteriori : L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta)","title":"Likelihood function"},{"location":"lectures/week_2/#maximum-likelihood-estimation","text":"The basic idea behind maximum likelihood estimation (MLE) is to pick values for our parameters which were most likely to have generated the data we saw \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) Note MLE is commonly used in statistics, and often leads to \"intuitive\", \"appealing\" or \"natural\" estimators. For IID data \\[p(\\mathcal D | \\theta) = \\prod_m p(x^{(m)} | \\theta)\\] \\[\\ell (\\theta ; D | \\theta) = \\sum_m log p(x^{(m)} | \\theta)\\] Note The IDD assumption turns the log likelihood into a sum, making the derivative easy to compute.","title":"Maximum likelihood estimation"},{"location":"lectures/week_2/#sufficient-statistics","text":"A statistic is a (possibly vector valued) deterministic function of a (set of) random variable(s). A sufficient statistic is a statistic that conveys exactly the same information about the data generating process that created that data as the entire data itself. In other words, once we know the sufficient statistic, T(x) T(x) , then our inferences are the same as would be obtained from our entire data. More formally, we say that T(X) T(X) is a sufficient statistic for X X if T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta Put another way P(\\theta | T(X)) = P(\\theta | X) P(\\theta | T(X)) = P(\\theta | X) Note Why is the useful? Well, if we have a particular large data sample, a lot of the data may be redundant. If we knew the sufficient statistic for that sample, we could use it in place of the full data sample. Equivalently (by the Neyman factorization theorem) we can write P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) An example is the exponential family p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\}","title":"Sufficient statistics"},{"location":"lectures/week_2/#sufficient-statistics-example-bernoulli-trials","text":"Let us take the example of flipping a fair coin. This process that generates our data is can be modeled as a Bernoulli distribution X \\backsim \\text{Ber}(\\theta) X \\backsim \\text{Ber}(\\theta) where X X is a random variable and x_i x_i represents the result of the ith coin flip \\[x_i = 0 \\text{ , if tails}\\] \\[x_i = 1 \\text{ , if heads}\\] the likelihood (assuming independence between flips of the coin) is \\[L = \\prod_{i=1}^N \\theta^{x_i}(1-\\theta)^{1-x_i}\\] \\[= \\theta^{\\sum_{i=1}^N x_i}(1-\\theta)^{N-\\sum_{i=1}^N x_i}\\] \\[= T(x)(1-\\theta)^{N-T(X)}\\] So we notice here that our likelihood depends on \\sum_{i=1}^N x_i \\sum_{i=1}^N x_i . In other words, our data only enters the likelihood in this particular form. This tells us that if we know this summary statistic, which we will call T(x) = \\sum_{i=1}^N x_i T(x) = \\sum_{i=1}^N x_i then essentially we know everything that is useful from our sample to do inference. To perform inference with T(x) T(x) , we define the log likelihood \\[\\ell(\\theta ; X) = \\log p(X | \\theta)\\] \\[ = T(X) \\log \\theta - (N - T(X)) \\log(1-\\theta) \\] then we take the derivative and set it to 0 to find the maximum \\frac{\\partial \\ell}{\\partial \\theta} = 0 = \\frac{T(X)}{N} \\frac{\\partial \\ell}{\\partial \\theta} = 0 = \\frac{T(X)}{N} This is our maximum likelihood estimation of the parameters \\theta \\theta , \\theta^{\\star}_{ML} \\theta^{\\star}_{ML} . Note See Lecture 2 slides 10-13 for more examples.","title":"Sufficient statistics example: Bernoulli Trials"},{"location":"lectures/week_2/#summary-of-probabilistic-models","text":"In general, learning the parameters of a probabilistic model depends on whether our variables are observed or partially observed, continuous or discrete Continuous Discrete Fully observed variables Bespoke estimates from calculus Normalized counts Partially observed variables Variational inference, recognition networks, MCMC Message passing, variable elimination, junction tree","title":"Summary of Probabilistic Models"},{"location":"lectures/week_2/#appendix","text":"","title":"Appendix"},{"location":"lectures/week_2/#useful-resources","text":"Helpful video on sufficient statistics.","title":"Useful Resources"},{"location":"lectures/week_2/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"lectures/week_3/","text":"Week 3: Directed Graphical Models Assigned Reading Murphy: Chapters 10-12 (excluding * sections) Kevin Murphy's page on graphical models Roger Grosse's slides on backprop Overview Graphical notations Conditional independence Bayes Balls Latent variables Common motifs Graphical model notation The joint distribution of N N random variables can be computed by the chain rule p(x_{1, ..., N}) = p(x_1)p(x_2|x_1)p(x_3 | x_2, x_1)) \\ldots p(x_{1, ..., N}) = p(x_1)p(x_2|x_1)p(x_3 | x_2, x_1)) \\ldots this is true for any joint distribution over any random variables . More formally, in probability the chain rule for two random variables is p(x, y) = p(x | y)p(y) p(x, y) = p(x | y)p(y) and for N N random variables p(\\cap^N_{i=1}) = \\prod_{k=1}^N p(x_k | \\cap^{k-1}_{j=1} x_j) p(\\cap^N_{i=1}) = \\prod_{k=1}^N p(x_k | \\cap^{k-1}_{j=1} x_j) Note Note that this is a bit of an abuse of notation, but p(x_k | \\cap^{k-1}_{j=1} x_j) p(x_k | \\cap^{k-1}_{j=1} x_j) will collpase to p(x_1) p(x_1) when k k = 1. Graphical, we might represent a model p(x_i, x_{\\pi_i}) = p(x_{\\pi_i})p(x_i | x_{\\pi_i}) p(x_i, x_{\\pi_i}) = p(x_{\\pi_i})p(x_i | x_{\\pi_i}) as where nodes represent random variables arrows mean \"conditioned on\", e.g. \" x_i x_i is conditioned on x_{\\pi_1} x_{\\pi_1} \". For example, the graphical model p(x_{1, ..., 6}) p(x_{1, ..., 6}) is represented as This is what the model looks like with no assumptions on the conditional dependence between variables (said otherwise, we assume full conditional dependence of the joint distribution as per the chain rule). This model will scale poorly (exponential with the number of parameters). We can simplify the model by building in our assumptions about the conditional probabilites. Conditional Independence Let X X be the set of nodes in our graph (the random variables of our model), then \\[(X_A \\perp X_B | X_C)\\] \\[\\Leftrightarrow p(X_A, X_B | X_C) = p(X_A | X_C)p(X_B | X_C) \\; (\\star)\\] \\[\\Leftrightarrow p(X_A | X_B, X_C) = p(X_A | X_C) \\; (\\star\\star)\\] Note \\star\\star \\star\\star is especially important, and we use this several times throughout the lecture. Directed acyclic graphical models (DAGM) A directed acyclic graphical model over N N random variables looks like p(x_{1, ..., N}) = \\prod_ip(x_i | x_{\\pi_i}) p(x_{1, ..., N}) = \\prod_ip(x_i | x_{\\pi_i}) where x_i x_i is a random variable (node in the graphical model) and x_{\\pi_i} x_{\\pi_i} are the parents of this node. In other words, the joint distribution of a DAGM factors into a product of conditional distributions, where each random variable (or node) is conditionally dependent on its parent node(s), which could be empty. Tip The Wikipedia entry on Graphical models is helpful, particularly the section on Bayesian networks . Notice the difference between a DAGM and the chain rule for probability we introduced early: we are only conditioning on parent nodes not every node . Furthermore, this distribution is exponential in the number of nodes in the parent set, not all of N N . Independence assumptions on DAGMs Lets look again at the graphical model p(x_{1, ..., 6}) p(x_{1, ..., 6}) we introduced above. First, lets sort the DAGM topologically. The conditional independence of our random variables becomes x_i \\bot x_{\\widetilde{\\pi_i}} | x_{\\pi_i} x_i \\bot x_{\\widetilde{\\pi_i}} | x_{\\pi_i} so random variables x_i x_i and x_{\\widetilde{\\pi_i}} x_{\\widetilde{\\pi_i}} are conditional independent of each other but conditional dependent on their parent nodes x_{\\pi_i} x_{\\pi_i} . Note To topological sort or order a DAGM means to sort all parents before their children. Lastly, lets place some assumptions on the conditional dependence of our random variables. Say our model looks like What have the assumptions done to our joint distribution represented by our model? p(x_{1, ..., 6}) = p(x_1)p(x_2 | x_1)p(x_3 | x_1)p(x_4 | x_2)p(x_5 | x_3)p(x_6 | x_2, x_5) p(x_{1, ..., 6}) = p(x_1)p(x_2 | x_1)p(x_3 | x_1)p(x_4 | x_2)p(x_5 | x_3)p(x_6 | x_2, x_5) Cleary our assumptions on conditional independence have vastly simplified the model. Suppose each is x_i x_i is a binary random variable. Our assumptions on conditional independence also reduce the dimensionality of our model D-Separation D-separation , or directed-separation is a notion of connectedness in DAGMs in which two (sets of) variables may or may not be connected conditioned on a third (set of) variable(s); where D-connection implies conditional dependence and d-separation implies conditional independence . In particular, we say that x_A \\bot x_B | x_C x_A \\bot x_B | x_C if every variable in A A is d-separated from every variable in B B conditioned on all the variables in C C . We will look at two methods for checking if an independence is true: A depth-first search algorithm and Bayes Balls . DFS Algorithm for checking independence To check if an independence is true, we can cycle through each node in A A , do a depth-first search to reach every node in B B , and examine the path between them. If all of the paths are d-separated, then we can assert x_A \\bot x_B | x_C x_A \\bot x_B | x_C Thus, it will be sufficient to consider triples of nodes. Note It is not totally clear to me why it is sufficient to consider triples of nodes. This is simply stated \"as is\" on the lecture slides. Lets go through some of the most common triples. Tip It was suggested in class that these types of examples make for really good midterm questions! 1. Chain Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(x)P(y|x)P(z|y) P(x, y, z) = P(x)P(y|x)P(z|y) which implies \\begin{align} P(z | x, y) = \\frac{P(x, y, z)}{P(x, y)} \\\\ = \\frac{P(x)P(y|x)P(z|y)}{P(x)P(y|x)} \\\\ = P(z | y) \\\\ \\end{align} \\begin{align} P(z | x, y) &= \\frac{P(x, y, z)}{P(x, y)} \\\\ &= \\frac{P(x)P(y|x)P(z|y)}{P(x)P(y|x)} \\\\ &= P(z | y) \\\\ \\end{align} \\therefore \\therefore P(z | x, y) = P(z | y) P(z | x, y) = P(z | y) and so by \\star\\star \\star\\star , x \\bot z | y x \\bot z | y . Tip It is helpful to think about x x as the past, y y as the present and z z as the future when working with chains such as this one. 2. Common Cause Where we think of y y as the \"common cause\" of the two independent effects x x and z z . Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(y)P(x|y)P(z|y) P(x, y, z) = P(y)P(x|y)P(z|y) which implies \\begin{align} P(x, z | y) = \\frac{P(x, y, z)}{P(y)} \\\\ = \\frac{P(y)P(x|y)P(z|y)}{P(y)} \\\\ = P(x|y)P(z|y) \\\\ \\end{align} \\begin{align} P(x, z | y) &= \\frac{P(x, y, z)}{P(y)} \\\\ &= \\frac{P(y)P(x|y)P(z|y)}{P(y)} \\\\ &= P(x|y)P(z|y) \\\\ \\end{align} \\therefore \\therefore P(x, z| y) = P(x|y)P(z|y) P(x, z| y) = P(x|y)P(z|y) and so by \\star \\star , x \\bot z | y x \\bot z | y . 3. Explaining Away Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(x)P(z)P(y|x, z) P(x, y, z) = P(x)P(z)P(y|x, z) which implies \\begin{align} P(z | x, y) = \\frac{P(x)P(z)P(y | x, z)}{P(x)P(y|x)} \\\\ = \\frac{P(z)P(y | x, z)}{P(y|x)} \\\\ \\not = P(z|y) \\\\ \\end{align} \\begin{align} P(z | x, y) &= \\frac{P(x)P(z)P(y | x, z)}{P(x)P(y|x)} \\\\ &= \\frac{P(z)P(y | x, z)}{P(y|x)} \\\\ &\\not = P(z|y) \\\\ \\end{align} \\therefore \\therefore P(z | x, y) \\not = P(z|y) P(z | x, y) \\not = P(z|y) and so by \\star\\star \\star\\star , x \\not \\bot z | y x \\not \\bot z | y . In fact, x x and z z are marginally independent , but given y y they are conditionally independent . This important effect is called explaining away ( Berkson\u2019s paradox ). Example Imaging flipping two coins independently, represented by events x x and z z . Furthermore, let y=1 y=1 if the coins come up the same and y=0 y=0 if they come up differently. Clearly, x x and z z are independent, but if I tell you y y , they become coupled! Bayes-Balls Algorithm An alternative algorithm for determining conditional independence is the Bayes Balls algorithm. To check if x_A \\bot x_B | x_C x_A \\bot x_B | x_C we need to check if every variable in A A is d-seperated from every variable in B B conditioned on all variables in C C . In other words, given that all the nodes in x_C x_C are \"clamped\", when we \"wiggle\" nodes x_A x_A can we change any of the nodes in x_B x_B ? In general, the algorithm works as follows: We shade all nodes x_C x_C , place \"balls\" at each node in x_A x_A (or x_B x_B ), let them \"bounce\" around according to some rules, and then ask if any of the balls reach any of the nodes in x_B x_B (or x_A x_A ). The rules are as follows : including the boundary rules : where arrows indicate paths the balls can travel, and arrows with bars indicate paths the balls cannot travel. Note Notice balls can travel opposite to edge directions! Here\u2019s a trick for the explaining away case: If y y or any of its descendants is shaded , the ball passes through. Canonical Micrographs For reference, here are some canonical micrographs and the Bayes Balls algorithmic rules that apply to them Tip See this video for an easy way to remember all the rules. Examples Question : In the following graph, is x_1 \\bot x_6 | \\{x_2, x_3\\} x_1 \\bot x_6 | \\{x_2, x_3\\} ? Answer : Yes, by the Bayes Balls algorithm. Question : In the following graph, is x_2 \\bot x_3 | \\{x_1, x_6\\} x_2 \\bot x_3 | \\{x_1, x_6\\} ? Answer : No, by the Bayes Balls algorithm. Appendix Useful Resources Metacademy lesson on Bayes Balls . In fact, that link will bring you to a short course on a couple important concepts for this corse, including conditional probability, conditional independence, Bayesian networks and d-separation. A video on how to memorize the Bayes Balls rules (this is linked in the above course). Glossary of Terms","title":"Week 3"},{"location":"lectures/week_3/#week-3-directed-graphical-models","text":"","title":"Week 3: Directed Graphical Models"},{"location":"lectures/week_3/#assigned-reading","text":"Murphy: Chapters 10-12 (excluding * sections) Kevin Murphy's page on graphical models Roger Grosse's slides on backprop","title":"Assigned Reading"},{"location":"lectures/week_3/#overview","text":"Graphical notations Conditional independence Bayes Balls Latent variables Common motifs","title":"Overview"},{"location":"lectures/week_3/#graphical-model-notation","text":"The joint distribution of N N random variables can be computed by the chain rule p(x_{1, ..., N}) = p(x_1)p(x_2|x_1)p(x_3 | x_2, x_1)) \\ldots p(x_{1, ..., N}) = p(x_1)p(x_2|x_1)p(x_3 | x_2, x_1)) \\ldots this is true for any joint distribution over any random variables . More formally, in probability the chain rule for two random variables is p(x, y) = p(x | y)p(y) p(x, y) = p(x | y)p(y) and for N N random variables p(\\cap^N_{i=1}) = \\prod_{k=1}^N p(x_k | \\cap^{k-1}_{j=1} x_j) p(\\cap^N_{i=1}) = \\prod_{k=1}^N p(x_k | \\cap^{k-1}_{j=1} x_j) Note Note that this is a bit of an abuse of notation, but p(x_k | \\cap^{k-1}_{j=1} x_j) p(x_k | \\cap^{k-1}_{j=1} x_j) will collpase to p(x_1) p(x_1) when k k = 1. Graphical, we might represent a model p(x_i, x_{\\pi_i}) = p(x_{\\pi_i})p(x_i | x_{\\pi_i}) p(x_i, x_{\\pi_i}) = p(x_{\\pi_i})p(x_i | x_{\\pi_i}) as where nodes represent random variables arrows mean \"conditioned on\", e.g. \" x_i x_i is conditioned on x_{\\pi_1} x_{\\pi_1} \". For example, the graphical model p(x_{1, ..., 6}) p(x_{1, ..., 6}) is represented as This is what the model looks like with no assumptions on the conditional dependence between variables (said otherwise, we assume full conditional dependence of the joint distribution as per the chain rule). This model will scale poorly (exponential with the number of parameters). We can simplify the model by building in our assumptions about the conditional probabilites.","title":"Graphical model notation"},{"location":"lectures/week_3/#conditional-independence","text":"Let X X be the set of nodes in our graph (the random variables of our model), then \\[(X_A \\perp X_B | X_C)\\] \\[\\Leftrightarrow p(X_A, X_B | X_C) = p(X_A | X_C)p(X_B | X_C) \\; (\\star)\\] \\[\\Leftrightarrow p(X_A | X_B, X_C) = p(X_A | X_C) \\; (\\star\\star)\\] Note \\star\\star \\star\\star is especially important, and we use this several times throughout the lecture.","title":"Conditional Independence"},{"location":"lectures/week_3/#directed-acyclic-graphical-models-dagm","text":"A directed acyclic graphical model over N N random variables looks like p(x_{1, ..., N}) = \\prod_ip(x_i | x_{\\pi_i}) p(x_{1, ..., N}) = \\prod_ip(x_i | x_{\\pi_i}) where x_i x_i is a random variable (node in the graphical model) and x_{\\pi_i} x_{\\pi_i} are the parents of this node. In other words, the joint distribution of a DAGM factors into a product of conditional distributions, where each random variable (or node) is conditionally dependent on its parent node(s), which could be empty. Tip The Wikipedia entry on Graphical models is helpful, particularly the section on Bayesian networks . Notice the difference between a DAGM and the chain rule for probability we introduced early: we are only conditioning on parent nodes not every node . Furthermore, this distribution is exponential in the number of nodes in the parent set, not all of N N .","title":"Directed acyclic graphical models (DAGM)"},{"location":"lectures/week_3/#independence-assumptions-on-dagms","text":"Lets look again at the graphical model p(x_{1, ..., 6}) p(x_{1, ..., 6}) we introduced above. First, lets sort the DAGM topologically. The conditional independence of our random variables becomes x_i \\bot x_{\\widetilde{\\pi_i}} | x_{\\pi_i} x_i \\bot x_{\\widetilde{\\pi_i}} | x_{\\pi_i} so random variables x_i x_i and x_{\\widetilde{\\pi_i}} x_{\\widetilde{\\pi_i}} are conditional independent of each other but conditional dependent on their parent nodes x_{\\pi_i} x_{\\pi_i} . Note To topological sort or order a DAGM means to sort all parents before their children. Lastly, lets place some assumptions on the conditional dependence of our random variables. Say our model looks like What have the assumptions done to our joint distribution represented by our model? p(x_{1, ..., 6}) = p(x_1)p(x_2 | x_1)p(x_3 | x_1)p(x_4 | x_2)p(x_5 | x_3)p(x_6 | x_2, x_5) p(x_{1, ..., 6}) = p(x_1)p(x_2 | x_1)p(x_3 | x_1)p(x_4 | x_2)p(x_5 | x_3)p(x_6 | x_2, x_5) Cleary our assumptions on conditional independence have vastly simplified the model. Suppose each is x_i x_i is a binary random variable. Our assumptions on conditional independence also reduce the dimensionality of our model","title":"Independence assumptions on DAGMs"},{"location":"lectures/week_3/#d-separation","text":"D-separation , or directed-separation is a notion of connectedness in DAGMs in which two (sets of) variables may or may not be connected conditioned on a third (set of) variable(s); where D-connection implies conditional dependence and d-separation implies conditional independence . In particular, we say that x_A \\bot x_B | x_C x_A \\bot x_B | x_C if every variable in A A is d-separated from every variable in B B conditioned on all the variables in C C . We will look at two methods for checking if an independence is true: A depth-first search algorithm and Bayes Balls .","title":"D-Separation"},{"location":"lectures/week_3/#dfs-algorithm-for-checking-independence","text":"To check if an independence is true, we can cycle through each node in A A , do a depth-first search to reach every node in B B , and examine the path between them. If all of the paths are d-separated, then we can assert x_A \\bot x_B | x_C x_A \\bot x_B | x_C Thus, it will be sufficient to consider triples of nodes. Note It is not totally clear to me why it is sufficient to consider triples of nodes. This is simply stated \"as is\" on the lecture slides. Lets go through some of the most common triples. Tip It was suggested in class that these types of examples make for really good midterm questions! 1. Chain Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(x)P(y|x)P(z|y) P(x, y, z) = P(x)P(y|x)P(z|y) which implies \\begin{align} P(z | x, y) = \\frac{P(x, y, z)}{P(x, y)} \\\\ = \\frac{P(x)P(y|x)P(z|y)}{P(x)P(y|x)} \\\\ = P(z | y) \\\\ \\end{align} \\begin{align} P(z | x, y) &= \\frac{P(x, y, z)}{P(x, y)} \\\\ &= \\frac{P(x)P(y|x)P(z|y)}{P(x)P(y|x)} \\\\ &= P(z | y) \\\\ \\end{align} \\therefore \\therefore P(z | x, y) = P(z | y) P(z | x, y) = P(z | y) and so by \\star\\star \\star\\star , x \\bot z | y x \\bot z | y . Tip It is helpful to think about x x as the past, y y as the present and z z as the future when working with chains such as this one. 2. Common Cause Where we think of y y as the \"common cause\" of the two independent effects x x and z z . Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(y)P(x|y)P(z|y) P(x, y, z) = P(y)P(x|y)P(z|y) which implies \\begin{align} P(x, z | y) = \\frac{P(x, y, z)}{P(y)} \\\\ = \\frac{P(y)P(x|y)P(z|y)}{P(y)} \\\\ = P(x|y)P(z|y) \\\\ \\end{align} \\begin{align} P(x, z | y) &= \\frac{P(x, y, z)}{P(y)} \\\\ &= \\frac{P(y)P(x|y)P(z|y)}{P(y)} \\\\ &= P(x|y)P(z|y) \\\\ \\end{align} \\therefore \\therefore P(x, z| y) = P(x|y)P(z|y) P(x, z| y) = P(x|y)P(z|y) and so by \\star \\star , x \\bot z | y x \\bot z | y . 3. Explaining Away Question : When we condition on y y , are x x and z z independent? Answer : From the graph, we get P(x, y, z) = P(x)P(z)P(y|x, z) P(x, y, z) = P(x)P(z)P(y|x, z) which implies \\begin{align} P(z | x, y) = \\frac{P(x)P(z)P(y | x, z)}{P(x)P(y|x)} \\\\ = \\frac{P(z)P(y | x, z)}{P(y|x)} \\\\ \\not = P(z|y) \\\\ \\end{align} \\begin{align} P(z | x, y) &= \\frac{P(x)P(z)P(y | x, z)}{P(x)P(y|x)} \\\\ &= \\frac{P(z)P(y | x, z)}{P(y|x)} \\\\ &\\not = P(z|y) \\\\ \\end{align} \\therefore \\therefore P(z | x, y) \\not = P(z|y) P(z | x, y) \\not = P(z|y) and so by \\star\\star \\star\\star , x \\not \\bot z | y x \\not \\bot z | y . In fact, x x and z z are marginally independent , but given y y they are conditionally independent . This important effect is called explaining away ( Berkson\u2019s paradox ). Example Imaging flipping two coins independently, represented by events x x and z z . Furthermore, let y=1 y=1 if the coins come up the same and y=0 y=0 if they come up differently. Clearly, x x and z z are independent, but if I tell you y y , they become coupled!","title":"DFS Algorithm for checking independence"},{"location":"lectures/week_3/#bayes-balls-algorithm","text":"An alternative algorithm for determining conditional independence is the Bayes Balls algorithm. To check if x_A \\bot x_B | x_C x_A \\bot x_B | x_C we need to check if every variable in A A is d-seperated from every variable in B B conditioned on all variables in C C . In other words, given that all the nodes in x_C x_C are \"clamped\", when we \"wiggle\" nodes x_A x_A can we change any of the nodes in x_B x_B ? In general, the algorithm works as follows: We shade all nodes x_C x_C , place \"balls\" at each node in x_A x_A (or x_B x_B ), let them \"bounce\" around according to some rules, and then ask if any of the balls reach any of the nodes in x_B x_B (or x_A x_A ). The rules are as follows : including the boundary rules : where arrows indicate paths the balls can travel, and arrows with bars indicate paths the balls cannot travel. Note Notice balls can travel opposite to edge directions! Here\u2019s a trick for the explaining away case: If y y or any of its descendants is shaded , the ball passes through.","title":"Bayes-Balls Algorithm"},{"location":"lectures/week_3/#canonical-micrographs","text":"For reference, here are some canonical micrographs and the Bayes Balls algorithmic rules that apply to them Tip See this video for an easy way to remember all the rules.","title":"Canonical Micrographs"},{"location":"lectures/week_3/#examples","text":"Question : In the following graph, is x_1 \\bot x_6 | \\{x_2, x_3\\} x_1 \\bot x_6 | \\{x_2, x_3\\} ? Answer : Yes, by the Bayes Balls algorithm. Question : In the following graph, is x_2 \\bot x_3 | \\{x_1, x_6\\} x_2 \\bot x_3 | \\{x_1, x_6\\} ? Answer : No, by the Bayes Balls algorithm.","title":"Examples"},{"location":"lectures/week_3/#appendix","text":"","title":"Appendix"},{"location":"lectures/week_3/#useful-resources","text":"Metacademy lesson on Bayes Balls . In fact, that link will bring you to a short course on a couple important concepts for this corse, including conditional probability, conditional independence, Bayesian networks and d-separation. A video on how to memorize the Bayes Balls rules (this is linked in the above course).","title":"Useful Resources"},{"location":"lectures/week_3/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"tutorials/week_1/","text":"","title":"Week 1"}]}