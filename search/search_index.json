{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CSC412/2506 Winter 2019: Probabilistic Learning and Reasoning \u00b6 Course Website Course Information Sheet When and Where \u00b6 Lectures: Tuesdays 15:00-17:00 in SS 2117 Tutorials: Thursday 13:00-14:00 in SS 2117","title":"About"},{"location":"#csc4122506-winter-2019-probabilistic-learning-and-reasoning","text":"Course Website Course Information Sheet","title":"CSC412/2506 Winter 2019: Probabilistic Learning and Reasoning"},{"location":"#when-and-where","text":"Lectures: Tuesdays 15:00-17:00 in SS 2117 Tutorials: Thursday 13:00-14:00 in SS 2117","title":"When and Where"},{"location":"lectures/week_1/","text":"Week 1: Introduction \u00b6 Assigned Reading \u00b6 Murphy: Chapters 1 and 2 Chapter 2 of David Mackay's textbook Overview \u00b6 Course information Overview of ML with examples Ungraded, anonymous background quiz Textbook and Resources \u00b6 There is no required textbook, but optional reading will be assigned each week Kevin Murphy (2012), Machine Learning: A Probabilistic Perspective . David MacKay (2003) Information Theory, Inference, and Learning Algorithms . The David MacKay textbook is recommended, although 100% of tested material come from class. In this course, lecture slides are more a supplement then main content. The most important stuff will be done on the blackboard, so it is important to come to class with pen and paper. Tutorial slides are relevant, but probably won't be tested. Assignments \u00b6 Assignments must be your own individual work. You can collaborate with up to 2 other students. You should name these people in your submission. Code should be readable . Make sure to put all plots and important results in your PDF submission. Related Courses \u00b6 CSC411: List of methods, (K-NN, Decision trees), more focus on computation STA302: Linear regression and classical stats ECE521: Similar material, more focus on computation STA414: Mostly same material, slightly more emphasis on theory than coding CSC321: Neural networks - about 30% overlap Stats vs Machine Learning \u00b6 Statisticians look at the data, consider the problem, and design a model we can understand. They Analyze methods to give guarantees Want to make few assumptions In machine learning , We only care about making good predictions! The basic idea is to learn a general procedure that works for lots of datasets. Often, there is no way around making assumptions, so we make our model large enough to hopefully learn something close to the truth. We can't use bounds in practice, so we evaluate and empirically choose model details. Sometimes, we end up with interpretable models anyways! In short, statistics starts with a model based on the data , machine learning aims to learn a model from the data. Types of Learning \u00b6 Unsupervised Learning: Given unlabeled data instances x_1 x_1 , x_2 x_2 , x_3 x_3 ... build a statistical model of x x , which can be used for making predictions, decisions. Supervised Learning: Given input-output pairs (x,y) (x,y) the goal is to predict correct output given a new input. Semi-supervised Learning: We are given only a limited amount of (x, y) (x, y) pairs, but lots of unlabeled x x 's Active learning and RL: Also get to choose actions that influence (x, y) (x, y) pairs, but lots of unlabeled x x \u2019s. future information + reward. Can just use basic decision theory. Note that these are all just special cases of estimating distributions from data: p(y | x) p(y | x) , p(x) p(x) , p(x, y) p(x, y) ! Finding Structure in Data \u00b6 With a big enough dataset, we can identify structure in the data. Take a large newswire corpus, for example. A simple model based on the word counts of webpages \\[P(x) = \\frac{1}{Z} \\sum_h \\exp [x^TWh]\\] could learn to discretize data into topics. In this case, our topics are our hidden (or latent ) variables. Note Sometimes latent variables correspond to aspects of physical reality, which could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are \"really there\", but hidden). Matrix Factorization \u00b6 Lets take a look at a specific example which uses matrix factorization for collaborative filtering . Part of the winning solution in the Netflix contest started with a Netflix dataset of 480,189 users, 17,770 movies and over 100 million ratings. The job was essentially to \"fill-in\" the missing information in a table that looked something like the following (hence the collaborative in collaborative filtering): After the modal was learned, it was clear that the latent representations it learned closley mapped what we might call genre : Multiple Kinds of Data in One Model \u00b6 My modeling the joint distribution of our data p(x, y) p(x, y) , we can incorporate multiple types of data under one model. In this example, our dataset consists of both images and text. Once the joint distribution is learned, we could provide a word and ask the model to sample from the learned distribution and return a picture (or vice versa!): Info Nguyen A, Dosovitskiy A, Yosinski J, Brox T, Clune J (2016). Synthesizing the preferred inputs for neurons in neural networks via deep generator networks. Advances in Neural Information Processing Systems 29 In fact, this is the key idea behind image captioning models: Latent Representations \u00b6 Once learned, latent representations of our data allow us to do some powerful things. For example, neural networks that are able to fill-in occuluded (or missing) portions of digital images: Info Pixel Recurrent Neural Networks. Aaron van den Oord, Nal Kalchbrenner, Koray Kavukcuoglu Because our latent space is really a vector space , we have access to all the mathematical operations that are defined on vectors, such as addition and subtraction . Furthermore, out latent representations (which themselves are just vector learned during model training) can be decoded into images (or words, or molecules, etc!). For example, if we were to learn latent representations of human faces, we could add and subtract these representations to create entirely new representations: Latent Representations of Structured Data \u00b6 Some data is structured in a way that is semantically meaningful. Put another way, there is a \"grammar\" to the data. Take the example of molecules representing pharmaceutical drugs. In this case, it is much more difficult to interpolate between two valid structures than it would be to interpolate between images of human faces, for example, because of the grammar of organic chemistry. Simplifying this point, two molecules that look extremely similar could in fact have wildly different behavior in the human body. The take-home point is that we need different methods for learning latent representations of structured data than unstructured data Course Themes \u00b6 This course will follow the broad theme of starting with a simple model and then adding to it. Example Linear regression and principal component analysis (PCA) are special cases of almost everything. A few \"lego bricks\" are enough to build most models (e.g. gaussians, categorical variables, linear transforms and neural networks). While the exact for of each distribution / function shouldn't mater much, your model should have a million parameters in it somewhere (the real world is messy!) Model checking is hard, but important. Learning algorithms are especially hard to debug. Computation \u00b6 Later assignments will involve a bit of programming. You can use whatever language you want, but python and numpy are recommended. For fitting and inference in high-dimensional models, gradient-based methods are basically the only game in town Lots of methods conflate model and fitting algorithm, we will try to separate these. ML as a Bag of Tricks \u00b6 Fast special cases Extensible family K-means Mixture of Gaussians Kernel Density Estimation Latent variable models SVMs Gaussian processes Boosting Deep neural nets Random Forests Bayesian neural nets K-Nearest Neighbours ?? Regularization as a Bag of Tricks \u00b6 Fast special cases Extensible family Early stopping Ensembling L2 Regularization Stochastic variational inference Gradient noise Dropout Expectation-Maximization A Language of Models \u00b6 Our goal will be to develop a language of models, a toolbox . For example, hidden Markov models, mixture of Gaussians, and logistic regression are all examples from a language of models. We will try to show a larger family, and point out common special cases. Using this language, you will be able to build you own custom models. In fact, we can talk about this family of models using very few ideas. Really, all we need are deep probabilistic latent-variable models and some decision theory . Russel and Norvig\u2019s parts of AI Extensible family Machine learning Natural language processing Knowledge representation Deep probabilistic latent-variable models + decision theory Automated reasoning Computer vision Robotics Advantages of probabilistic latent-variable models \u00b6 Data-efficient Learning Automatic regularization, can take advantage of more information. Model is aware what it doesn\u2019t know. E.g. after many cat images model updates get small. Showing a dog image for the first time would lead to large updates.\u0000 Compos-able models Models are built like lego blocks. E.g. you could incorporate a data corruption model. Handle Missing & Corrupted Data Latent-variable models can easily handle missing and corrupted data, without the standard hacks of guessing missing values using averages. Predictive Uncertainty Necessary for decision-making. Bad models can confidently give us bad predictions. So can good modals! The key is to be able to express uncertainty. Conditional Predictions Be able to condition predictions can be powerful. E.g. if brexit happens, the value of the pound will fall. Active Learning What data would be expected to increase our confidence about a prediction. Disadvantages of Probabilistic Latent-variable Models \u00b6 Intractable integral over latent variables. Integrating over many dimensions is difficult and sometimes intractable. Probabilistic Graphical Models Vs. Neural Networks \u00b6 Imagine we had the following data we may try to model this data by fitting a mixture of Gaussians, as so which seems perfectly reasonable in this case. However, imagine instead we had the following data the use of a mixture model may not be appropriate in this case, as it fits the data poorly and reports too many clusters but a neural network who's job is to come up with a convincing distribution over where you can expect to see data does much better this brings us to a comparison of probabilistic graphical models and deep learning Probabilistic graphical models Deep learning \u2795 structured representations \u2796 neural net \"goo\" \u2795 priors and uncertainty \u2796 difficult parameterization \u2795 data and computational efficiency \u2796 can require lots of data \u2796 rigid assumptions may not fit \u2795 flexible \u2796 feature engineering \u2795 feature learning \u2796top-down inference \u2795 recognition networks \u2757 Left off on slide 35 The Unreasonable Easiness of Deep Learning \u00b6 The deep learning recipe involves defining an objective function (i.e. a probability of data given parameters) and optimizing the parameters to maximize the object. Gradients are computed automatically, you just need to define a model by some computation. Differentiable models \u00b6 Differentiable models, in general, follow these general principals 1. Model Distributions implicitly by a variable pushed through a deep net \\[y = f_{\\theta}(x) ; x \\sim \\mathcal N(0, I) \\] 2. Approximate intractable distribution by a tractable distribution parameterized by a deep net \\[p(y | x) = \\mathcal N(y | \\mu = f_{\\theta}(x), \\Sigma = g_{\\theta}(x))] ; x \\sim \\mathcal N(0, I) \\] 3. Optimize all parameters using stochastic gradient descent Modeling Idea \u00b6 Graphical models and neural networks have complimentary strengths, and can be combined. One such way to combine these models is by using structured prior distributions formulated as graphical models with highly nonlinear observation models implemented using neural networks . By pushing these structured prior distributions through a neural network we can get a model which takes exploits the best of both worlds This idea can be extended to supervised or unsupervised learning Learning Outcomes \u00b6 Know standard algorithms (bag of tricks), when to use them, and their limitations. For basic applications and baselines. Know main elements of language of deep probabilistic models (bag of bricks: distributions, expectations, latent variables, neural networks) and how to combine them. For custom applications + research. Know standard computational tools (Monte Carlo, Stochastic optimization, regularization, automatic differentiation). For fitting models. Tentative List of Topics \u00b6 Linear methods for regression + classification Bayesian linear regression Probabilistic Generative and Discriminative models - Regularization methods Stochastic Optimization and Neural Networks Graphical model notation and exact inference Mixture Models, Bayesian Networks Model Comparison and marginal likelihood Stochastic Variational Inference Time series and recurrent models Gaussian processes Variational Autoencoders Machine-learning-centric History of Probabilistic Models \u00b6 1940s - 1960s Motivating probability and Bayesian inference 1980s - 2000s Bayesian machine learning with MCMC 1990s - 2000s Graphical models with exact inference 1990s - present Bayesian Nonparametrics with MCMC (Indian Buffet process, Chinese restaurant process) 1990s - 2000s Bayesian ML with mean-field variational inference 2000s - present Probabilistic Programming 2000s - 2013 Deep undirected graphical models (RBMs, pretraining) 2010s - present Stan - Bayesian Data Analysis with HMC 2000s - 2013 Autoencoders, denoising autoencoders 2000s - present Invertible density estimation 2013 - present Stochastic variational inference, variational autoencoders 2014 - present Generative adversarial nets, Real NVP, Pixelnet 2016 - present Lego-style deep generative models (attend, infer, repeat) Appendix \u00b6 Useful Resources \u00b6 Blog + tutorial on matrix factorization for movie recommendation. Glow an interactive OpenAI blog on Generative Models. It appears that a few of these slides were taken straight from this video. https://en.wikipedia.org/wiki/Notation_in_probability_and_statistics Glossary of Terms \u00b6","title":"Week 1"},{"location":"lectures/week_1/#week-1-introduction","text":"","title":"Week 1: Introduction"},{"location":"lectures/week_1/#assigned-reading","text":"Murphy: Chapters 1 and 2 Chapter 2 of David Mackay's textbook","title":"Assigned Reading"},{"location":"lectures/week_1/#overview","text":"Course information Overview of ML with examples Ungraded, anonymous background quiz","title":"Overview"},{"location":"lectures/week_1/#textbook-and-resources","text":"There is no required textbook, but optional reading will be assigned each week Kevin Murphy (2012), Machine Learning: A Probabilistic Perspective . David MacKay (2003) Information Theory, Inference, and Learning Algorithms . The David MacKay textbook is recommended, although 100% of tested material come from class. In this course, lecture slides are more a supplement then main content. The most important stuff will be done on the blackboard, so it is important to come to class with pen and paper. Tutorial slides are relevant, but probably won't be tested.","title":"Textbook and Resources"},{"location":"lectures/week_1/#assignments","text":"Assignments must be your own individual work. You can collaborate with up to 2 other students. You should name these people in your submission. Code should be readable . Make sure to put all plots and important results in your PDF submission.","title":"Assignments"},{"location":"lectures/week_1/#related-courses","text":"CSC411: List of methods, (K-NN, Decision trees), more focus on computation STA302: Linear regression and classical stats ECE521: Similar material, more focus on computation STA414: Mostly same material, slightly more emphasis on theory than coding CSC321: Neural networks - about 30% overlap","title":"Related Courses"},{"location":"lectures/week_1/#stats-vs-machine-learning","text":"Statisticians look at the data, consider the problem, and design a model we can understand. They Analyze methods to give guarantees Want to make few assumptions In machine learning , We only care about making good predictions! The basic idea is to learn a general procedure that works for lots of datasets. Often, there is no way around making assumptions, so we make our model large enough to hopefully learn something close to the truth. We can't use bounds in practice, so we evaluate and empirically choose model details. Sometimes, we end up with interpretable models anyways! In short, statistics starts with a model based on the data , machine learning aims to learn a model from the data.","title":"Stats vs Machine Learning"},{"location":"lectures/week_1/#types-of-learning","text":"Unsupervised Learning: Given unlabeled data instances x_1 x_1 , x_2 x_2 , x_3 x_3 ... build a statistical model of x x , which can be used for making predictions, decisions. Supervised Learning: Given input-output pairs (x,y) (x,y) the goal is to predict correct output given a new input. Semi-supervised Learning: We are given only a limited amount of (x, y) (x, y) pairs, but lots of unlabeled x x 's Active learning and RL: Also get to choose actions that influence (x, y) (x, y) pairs, but lots of unlabeled x x \u2019s. future information + reward. Can just use basic decision theory. Note that these are all just special cases of estimating distributions from data: p(y | x) p(y | x) , p(x) p(x) , p(x, y) p(x, y) !","title":"Types of Learning"},{"location":"lectures/week_1/#finding-structure-in-data","text":"With a big enough dataset, we can identify structure in the data. Take a large newswire corpus, for example. A simple model based on the word counts of webpages \\[P(x) = \\frac{1}{Z} \\sum_h \\exp [x^TWh]\\] could learn to discretize data into topics. In this case, our topics are our hidden (or latent ) variables. Note Sometimes latent variables correspond to aspects of physical reality, which could in principle be measured, but may not be for practical reasons. In this situation, the term hidden variables is commonly used (reflecting the fact that the variables are \"really there\", but hidden).","title":"Finding Structure in Data"},{"location":"lectures/week_1/#matrix-factorization","text":"Lets take a look at a specific example which uses matrix factorization for collaborative filtering . Part of the winning solution in the Netflix contest started with a Netflix dataset of 480,189 users, 17,770 movies and over 100 million ratings. The job was essentially to \"fill-in\" the missing information in a table that looked something like the following (hence the collaborative in collaborative filtering): After the modal was learned, it was clear that the latent representations it learned closley mapped what we might call genre :","title":"Matrix Factorization"},{"location":"lectures/week_1/#multiple-kinds-of-data-in-one-model","text":"My modeling the joint distribution of our data p(x, y) p(x, y) , we can incorporate multiple types of data under one model. In this example, our dataset consists of both images and text. Once the joint distribution is learned, we could provide a word and ask the model to sample from the learned distribution and return a picture (or vice versa!): Info Nguyen A, Dosovitskiy A, Yosinski J, Brox T, Clune J (2016). Synthesizing the preferred inputs for neurons in neural networks via deep generator networks. Advances in Neural Information Processing Systems 29 In fact, this is the key idea behind image captioning models:","title":"Multiple Kinds of Data in One Model"},{"location":"lectures/week_1/#latent-representations","text":"Once learned, latent representations of our data allow us to do some powerful things. For example, neural networks that are able to fill-in occuluded (or missing) portions of digital images: Info Pixel Recurrent Neural Networks. Aaron van den Oord, Nal Kalchbrenner, Koray Kavukcuoglu Because our latent space is really a vector space , we have access to all the mathematical operations that are defined on vectors, such as addition and subtraction . Furthermore, out latent representations (which themselves are just vector learned during model training) can be decoded into images (or words, or molecules, etc!). For example, if we were to learn latent representations of human faces, we could add and subtract these representations to create entirely new representations:","title":"Latent Representations"},{"location":"lectures/week_1/#latent-representations-of-structured-data","text":"Some data is structured in a way that is semantically meaningful. Put another way, there is a \"grammar\" to the data. Take the example of molecules representing pharmaceutical drugs. In this case, it is much more difficult to interpolate between two valid structures than it would be to interpolate between images of human faces, for example, because of the grammar of organic chemistry. Simplifying this point, two molecules that look extremely similar could in fact have wildly different behavior in the human body. The take-home point is that we need different methods for learning latent representations of structured data than unstructured data","title":"Latent Representations of Structured Data"},{"location":"lectures/week_1/#course-themes","text":"This course will follow the broad theme of starting with a simple model and then adding to it. Example Linear regression and principal component analysis (PCA) are special cases of almost everything. A few \"lego bricks\" are enough to build most models (e.g. gaussians, categorical variables, linear transforms and neural networks). While the exact for of each distribution / function shouldn't mater much, your model should have a million parameters in it somewhere (the real world is messy!) Model checking is hard, but important. Learning algorithms are especially hard to debug.","title":"Course Themes"},{"location":"lectures/week_1/#computation","text":"Later assignments will involve a bit of programming. You can use whatever language you want, but python and numpy are recommended. For fitting and inference in high-dimensional models, gradient-based methods are basically the only game in town Lots of methods conflate model and fitting algorithm, we will try to separate these.","title":"Computation"},{"location":"lectures/week_1/#ml-as-a-bag-of-tricks","text":"Fast special cases Extensible family K-means Mixture of Gaussians Kernel Density Estimation Latent variable models SVMs Gaussian processes Boosting Deep neural nets Random Forests Bayesian neural nets K-Nearest Neighbours ??","title":"ML as a Bag of Tricks"},{"location":"lectures/week_1/#regularization-as-a-bag-of-tricks","text":"Fast special cases Extensible family Early stopping Ensembling L2 Regularization Stochastic variational inference Gradient noise Dropout Expectation-Maximization","title":"Regularization as a Bag of Tricks"},{"location":"lectures/week_1/#a-language-of-models","text":"Our goal will be to develop a language of models, a toolbox . For example, hidden Markov models, mixture of Gaussians, and logistic regression are all examples from a language of models. We will try to show a larger family, and point out common special cases. Using this language, you will be able to build you own custom models. In fact, we can talk about this family of models using very few ideas. Really, all we need are deep probabilistic latent-variable models and some decision theory . Russel and Norvig\u2019s parts of AI Extensible family Machine learning Natural language processing Knowledge representation Deep probabilistic latent-variable models + decision theory Automated reasoning Computer vision Robotics","title":"A Language of Models"},{"location":"lectures/week_1/#advantages-of-probabilistic-latent-variable-models","text":"Data-efficient Learning Automatic regularization, can take advantage of more information. Model is aware what it doesn\u2019t know. E.g. after many cat images model updates get small. Showing a dog image for the first time would lead to large updates.\u0000 Compos-able models Models are built like lego blocks. E.g. you could incorporate a data corruption model. Handle Missing & Corrupted Data Latent-variable models can easily handle missing and corrupted data, without the standard hacks of guessing missing values using averages. Predictive Uncertainty Necessary for decision-making. Bad models can confidently give us bad predictions. So can good modals! The key is to be able to express uncertainty. Conditional Predictions Be able to condition predictions can be powerful. E.g. if brexit happens, the value of the pound will fall. Active Learning What data would be expected to increase our confidence about a prediction.","title":"Advantages of probabilistic latent-variable models"},{"location":"lectures/week_1/#disadvantages-of-probabilistic-latent-variable-models","text":"Intractable integral over latent variables. Integrating over many dimensions is difficult and sometimes intractable.","title":"Disadvantages of Probabilistic Latent-variable Models"},{"location":"lectures/week_1/#probabilistic-graphical-models-vs-neural-networks","text":"Imagine we had the following data we may try to model this data by fitting a mixture of Gaussians, as so which seems perfectly reasonable in this case. However, imagine instead we had the following data the use of a mixture model may not be appropriate in this case, as it fits the data poorly and reports too many clusters but a neural network who's job is to come up with a convincing distribution over where you can expect to see data does much better this brings us to a comparison of probabilistic graphical models and deep learning Probabilistic graphical models Deep learning \u2795 structured representations \u2796 neural net \"goo\" \u2795 priors and uncertainty \u2796 difficult parameterization \u2795 data and computational efficiency \u2796 can require lots of data \u2796 rigid assumptions may not fit \u2795 flexible \u2796 feature engineering \u2795 feature learning \u2796top-down inference \u2795 recognition networks \u2757 Left off on slide 35","title":"Probabilistic Graphical Models Vs. Neural Networks"},{"location":"lectures/week_1/#the-unreasonable-easiness-of-deep-learning","text":"The deep learning recipe involves defining an objective function (i.e. a probability of data given parameters) and optimizing the parameters to maximize the object. Gradients are computed automatically, you just need to define a model by some computation.","title":"The Unreasonable Easiness of Deep Learning"},{"location":"lectures/week_1/#differentiable-models","text":"Differentiable models, in general, follow these general principals 1. Model Distributions implicitly by a variable pushed through a deep net \\[y = f_{\\theta}(x) ; x \\sim \\mathcal N(0, I) \\] 2. Approximate intractable distribution by a tractable distribution parameterized by a deep net \\[p(y | x) = \\mathcal N(y | \\mu = f_{\\theta}(x), \\Sigma = g_{\\theta}(x))] ; x \\sim \\mathcal N(0, I) \\] 3. Optimize all parameters using stochastic gradient descent","title":"Differentiable models"},{"location":"lectures/week_1/#modeling-idea","text":"Graphical models and neural networks have complimentary strengths, and can be combined. One such way to combine these models is by using structured prior distributions formulated as graphical models with highly nonlinear observation models implemented using neural networks . By pushing these structured prior distributions through a neural network we can get a model which takes exploits the best of both worlds This idea can be extended to supervised or unsupervised learning","title":"Modeling Idea"},{"location":"lectures/week_1/#learning-outcomes","text":"Know standard algorithms (bag of tricks), when to use them, and their limitations. For basic applications and baselines. Know main elements of language of deep probabilistic models (bag of bricks: distributions, expectations, latent variables, neural networks) and how to combine them. For custom applications + research. Know standard computational tools (Monte Carlo, Stochastic optimization, regularization, automatic differentiation). For fitting models.","title":"Learning Outcomes"},{"location":"lectures/week_1/#tentative-list-of-topics","text":"Linear methods for regression + classification Bayesian linear regression Probabilistic Generative and Discriminative models - Regularization methods Stochastic Optimization and Neural Networks Graphical model notation and exact inference Mixture Models, Bayesian Networks Model Comparison and marginal likelihood Stochastic Variational Inference Time series and recurrent models Gaussian processes Variational Autoencoders","title":"Tentative List of Topics"},{"location":"lectures/week_1/#machine-learning-centric-history-of-probabilistic-models","text":"1940s - 1960s Motivating probability and Bayesian inference 1980s - 2000s Bayesian machine learning with MCMC 1990s - 2000s Graphical models with exact inference 1990s - present Bayesian Nonparametrics with MCMC (Indian Buffet process, Chinese restaurant process) 1990s - 2000s Bayesian ML with mean-field variational inference 2000s - present Probabilistic Programming 2000s - 2013 Deep undirected graphical models (RBMs, pretraining) 2010s - present Stan - Bayesian Data Analysis with HMC 2000s - 2013 Autoencoders, denoising autoencoders 2000s - present Invertible density estimation 2013 - present Stochastic variational inference, variational autoencoders 2014 - present Generative adversarial nets, Real NVP, Pixelnet 2016 - present Lego-style deep generative models (attend, infer, repeat)","title":"Machine-learning-centric History of Probabilistic Models"},{"location":"lectures/week_1/#appendix","text":"","title":"Appendix"},{"location":"lectures/week_1/#useful-resources","text":"Blog + tutorial on matrix factorization for movie recommendation. Glow an interactive OpenAI blog on Generative Models. It appears that a few of these slides were taken straight from this video. https://en.wikipedia.org/wiki/Notation_in_probability_and_statistics","title":"Useful Resources"},{"location":"lectures/week_1/#glossary-of-terms","text":"","title":"Glossary of Terms"},{"location":"lectures/week_2/","text":"Week 2: Introduction to Probabilistic Models \u00b6 Assigned Reading \u00b6 Murphy: Chapters 3, 4, 7-9 (excluding * sections) Chapter 3 of David Mackay's textbook Overview \u00b6 Overview of probabilistic models Sufficient statistics Likelihood Maximum likelihood estimation (MLE) Classification Overview of probabilistic models \u00b6 In general, we have variables that can be observed or unobserved ( latent variables are always unobserved!). The job of a probabilistic model is to relate the variables (observed or unobserved). More specifically, a probabilistic learns a joint probability distribution over variables, e.g. p(x_1, x_2, ..., x_N) p(x_1, x_2, ..., x_N) . Because the distributions are parameterized, learning is essentially joint density estimation . In a generative model , we assume our data is generated by some distribution & then try to learn that distribution . The joint distribution (or joint density function) is the central object we use to define our model. From this perspective, we can think about the basic tasks we care about in machine learning (ML) as operations on joint distributions. One such task is classification Model : p(X, C) p(X, C) Task : p(C=c | x) = \\frac{p(c, x)}{p(x)} p(C=c | x) = \\frac{p(c, x)}{p(x)} where X X are our inputs, C C our classes and p(x) p(x) is the probability of our data (sometimes called the evidence ). p(x) p(x) can be re-written as the marginal probability p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} What happens if c c is never observed? Then we call this clustering . Clustering allows us to compute p(C=c|x) p(C=c|x) (\"the probability that the input belongs to some cluster\") even if c c is unobserved. If our inputs and classes are continuous, we call this regression p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} In general, if a variable is always observed, we may not want to model its density (regression / classification) if a variable is never observed (always unobserved) then we call it a hidden or latent variable and we may want to model its density (clustering, density estimation) In fact, we can mostly classify (no pun intended) the problems we care about into four types: Regression : p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} Classification : p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} Clustering : p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} Density Estimation : p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} Operations on Probabilistic Models \u00b6 The fundamental operations we will perform on a probabilistic modal are: Generate Data : For this you need to know how to sample from local models (directed) or how to do Gibbs or other sampling (undirected). Compute probabilities : When all nodes are either observed or marginalized the result is a single number which is the probability of the configuration. Inference : Compute expectations of some things given others which are observed or marginalized. Learning : Set the parameters of the joint distribution given some (partially) observed data to maximize the probability of seeing the data. Goals of a Probabilistic Model \u00b6 We want to build prediction systems automatically based on data, and as little as possible on expert information. In this course, we\u2019ll use probability to combine evidence from data and make predictions. We\u2019ll use graphical models as a visual shorthand language to express and reason about families of model assumptions, structures, dependencies and information flow, without specifying exact distributional forms or parameters. In this case learning means setting parameters of distributions given a model structure . Note \"Structure learning\" is also possible but we won\u2019t consider it now. More specifically, we want two things of our probabilistic model: Compact representation : we don't want parameters to scale poorly with dimensionality of the data. Efficient computation : we need to be able to compute the marginal and conditional probability from the join distribution efficiently. Multiple observations, Complete IID data \u00b6 A single observation of the data, X X is rarely useful on its own. Generally we have data including many observations, which creates a set of random variables: \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} To achieve our above-listed goals, we will make assumptions. Often, we assume the following: 1. Observations are independently and identically distributed (i.i.d) according to the joint distribution of the model. This reduces the computation of the conditional probability to the product of the individual probabilities of observations We don't always assume full independence. Sometimes, we assume only some level of independence between variables (e.g. var 3 depends on var 1 but not on var 2 ). 2. We observe all random variables in the domain on each observation (i.e. complete data, or fully observed model). We typically shade the nodes in a probabilistic graphical model to indicate they are observed. (Later we will work with unshaded nodes corresponding to missing data or latent variables.) Learning Parameters for a Distribution \u00b6 Lets take an example with discrete random variables . \\[ T: \\text{Temperature} ; t = \\text{\"hot\" or \"cold\"} \\] \\[ W: \\text{Weather} ; w = \\text{\"sunny\" or \"raining\"} \\] We know that \\[ P(T=h) = 0.40 \\] \\[ P(T=c) = 0.60 \\] \\[ P(W=s) = 0.70 \\] \\[ P(W=r) = 0.30 \\] and that these states define a valid probability distribution, so P(X) \\ge 0 ; \\sum_x P(x) = 1 P(X) \\ge 0 ; \\sum_x P(x) = 1 We could create a parameterized, probabilistic model, P(T, W) P(T, W) over the states \\[P(T | \\theta_T) ; \\theta_T = \\begin{bmatrix} 0.4 \\\\ 0.6 \\end{bmatrix}\\] \\[P(W | \\theta_W) ; \\theta_W = \\begin{bmatrix} 0.7 \\\\ 0.3 \\end{bmatrix}\\] Notice that \\theta_T \\theta_T and \\theta_W \\theta_W are the probability distributions of our random variables. Our parameters define the probability of the data explicitly and store it in a vector . We can represent the joint distribution P(T, W) P(T, W) , our model as: T W P h s 0.28 c r 0.18 h r 0.12 c s 0.42 from the joint distribution (which is again, essentially our model) we can compute the marginals \\[P(T=h) = \\sum_w P(T=h, W=w)\\] \\[ = 0.40\\] \\[P(T=c) = \\sum_w P(T=c, W=w)\\] \\[ = 0.60\\] \\[P(W=s) = \\sum_t P(W=s, T=t)\\] \\[ = 0.70\\] \\[P(W=r) = \\sum_t P(W=r, T=t)\\] \\[ = 0.30\\] and then we could ask questions about conditional probabilities, like P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 Why did we do this? \u00b6 The whole point of the above example was to show that from a probabilistic model, which itself is just a joint distribution represented as a matrix (or tensor), we can compute both the marginal and conditional probabilities. This will allow us to compute probabilities, generate data and perform inference. Joint Dimensionality \u00b6 Lets take our previous example and expand on it. Firstly, it is helpful to think of the joint distribution grid with k^n k^n squares, where n n is our number of variables and k k our states. For our running example, this means our joint distribution is parameterized by a 4 dimensional vector, containing the probabilities of seeing any pair of states. We could of course, add more random variables to our model. Imagine we add B B , for whether or not we bike into work and H H , for overall health , each with two states. The dimensionality of our parameters then becomes k^n = 2^4 k^n = 2^4 . It is important to note that our joint distribution will be computed based on the assumptions we make about independence between variables. For example, we could assume that while T T and W W are independent from one another, H H is dependent on both T T and W W as well as B B . From the chain rule, we get P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) Likelihood function \u00b6 So far, we have focused on the (log) probability function p(x|\\theta) p(x|\\theta) which assigns a probability (density) to any joint configuration of variables x x given fixed parameters \\theta \\theta . But our goal is to learn theta theta , which we do not start with and which is not fixed . This is the opposite of how we want to think. Really, we have some fixed data and we want to find parameters \\theta \\theta which maximize the likelihood of that data. Note We are asking \"given x x , how do I choose \\theta \\theta \". To do this, we define some function \\ell(\\theta ; x) = \\log p(x|\\theta) \\ell(\\theta ; x) = \\log p(x|\\theta) which we call the log likelihood function . Note The likelihood function is essentially a notational trick in order to make it easy to talk about our data as a function of our parameters. The process of learning is choosing \\theta \\theta to maximize some cost of loss function, L(\\theta) L(\\theta) which includes \\ell (\\theta) \\ell (\\theta) . This can be done in a couple of ways, including: Maximum likelihood estimation : L(\\theta) = \\ell (\\theta; \\mathcal D) L(\\theta) = \\ell (\\theta; \\mathcal D) Maximum a posteriori : L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) Maximum likelihood estimation \u00b6 The basic idea behind maximum likelihood estimation (MLE) is to pick values for our parameters which were most likely to have generated the data we saw \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) Note MLE is commonly used in statistics, and often leads to \"intuitive\", \"appealing\" or \"natural\" estimators. For IID data \\[p(\\mathcal D | \\theta) = \\prod_m p(x^{(m)} | \\theta)\\] \\[\\ell (\\theta ; D | \\theta) = \\sum_m log p(x^{(m)} | \\theta)\\] Note The IDD assumption turns the log likelihood into a sum, making the derivative easy to compute. Sufficient statistics \u00b6 A statistic is a (possibly vector valued) deterministic function of a (set of) random variable(s). A sufficient statistic is a statistic that conveys exactly the same information about the data generating process that created that data as the entire data itself. In other words, once we know the sufficient statistic, T(x) T(x) , then our inferences are the same as would be obtained from our entire data. More formally, we say that T(X) T(X) is a sufficient statistic for X X if T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta Put another way P(\\theta | T(X)) = P(\\theta | X) P(\\theta | T(X)) = P(\\theta | X) Note Why is the useful? Well, if we have a particular large data sample, a lot of the data may be redundant. If we knew the sufficient statistic for that sample, we could use it in place of the full data sample. Equivalently (by the Neyman factorization theorem) we can write P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) An example is the exponential family p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} Sufficient statistics example: Bernoulli Trials \u00b6","title":"Week 2"},{"location":"lectures/week_2/#week-2-introduction-to-probabilistic-models","text":"","title":"Week 2: Introduction to Probabilistic Models"},{"location":"lectures/week_2/#assigned-reading","text":"Murphy: Chapters 3, 4, 7-9 (excluding * sections) Chapter 3 of David Mackay's textbook","title":"Assigned Reading"},{"location":"lectures/week_2/#overview","text":"Overview of probabilistic models Sufficient statistics Likelihood Maximum likelihood estimation (MLE) Classification","title":"Overview"},{"location":"lectures/week_2/#overview-of-probabilistic-models","text":"In general, we have variables that can be observed or unobserved ( latent variables are always unobserved!). The job of a probabilistic model is to relate the variables (observed or unobserved). More specifically, a probabilistic learns a joint probability distribution over variables, e.g. p(x_1, x_2, ..., x_N) p(x_1, x_2, ..., x_N) . Because the distributions are parameterized, learning is essentially joint density estimation . In a generative model , we assume our data is generated by some distribution & then try to learn that distribution . The joint distribution (or joint density function) is the central object we use to define our model. From this perspective, we can think about the basic tasks we care about in machine learning (ML) as operations on joint distributions. One such task is classification Model : p(X, C) p(X, C) Task : p(C=c | x) = \\frac{p(c, x)}{p(x)} p(C=c | x) = \\frac{p(c, x)}{p(x)} where X X are our inputs, C C our classes and p(x) p(x) is the probability of our data (sometimes called the evidence ). p(x) p(x) can be re-written as the marginal probability p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} p(C=c | x) = \\frac{p(x, c)}{\\sum_i p(x, c_i)} What happens if c c is never observed? Then we call this clustering . Clustering allows us to compute p(C=c|x) p(C=c|x) (\"the probability that the input belongs to some cluster\") even if c c is unobserved. If our inputs and classes are continuous, we call this regression p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} p(y | x) = \\frac{p(x, y)}{p(x)} = \\frac{p(x, y)}{\\int p(x,y)dy} In general, if a variable is always observed, we may not want to model its density (regression / classification) if a variable is never observed (always unobserved) then we call it a hidden or latent variable and we may want to model its density (clustering, density estimation) In fact, we can mostly classify (no pun intended) the problems we care about into four types: Regression : p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} p(y | x) = \\frac{p(y, x)}{p(x)} = \\frac{p(y, x)}{\\int p(x)} Classification : p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} p(c | x) = \\frac{p(c, x)}{p(x)} = \\frac{p(c, x)}{\\sum_c p(c, x)} Clustering : p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} p(c | x) = \\frac{p(c, x)}{p(x)} ; c \\text{ is unobserved} Density Estimation : p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved} p(y | x) = \\frac{p(y, x)}{p(x)} ; y \\text{ is unobserved}","title":"Overview of probabilistic models"},{"location":"lectures/week_2/#operations-on-probabilistic-models","text":"The fundamental operations we will perform on a probabilistic modal are: Generate Data : For this you need to know how to sample from local models (directed) or how to do Gibbs or other sampling (undirected). Compute probabilities : When all nodes are either observed or marginalized the result is a single number which is the probability of the configuration. Inference : Compute expectations of some things given others which are observed or marginalized. Learning : Set the parameters of the joint distribution given some (partially) observed data to maximize the probability of seeing the data.","title":"Operations on Probabilistic Models"},{"location":"lectures/week_2/#goals-of-a-probabilistic-model","text":"We want to build prediction systems automatically based on data, and as little as possible on expert information. In this course, we\u2019ll use probability to combine evidence from data and make predictions. We\u2019ll use graphical models as a visual shorthand language to express and reason about families of model assumptions, structures, dependencies and information flow, without specifying exact distributional forms or parameters. In this case learning means setting parameters of distributions given a model structure . Note \"Structure learning\" is also possible but we won\u2019t consider it now. More specifically, we want two things of our probabilistic model: Compact representation : we don't want parameters to scale poorly with dimensionality of the data. Efficient computation : we need to be able to compute the marginal and conditional probability from the join distribution efficiently.","title":"Goals of a Probabilistic Model"},{"location":"lectures/week_2/#multiple-observations-complete-iid-data","text":"A single observation of the data, X X is rarely useful on its own. Generally we have data including many observations, which creates a set of random variables: \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} \\mathcal D = \\{x^{(1)}, ..., x^{(M)}\\} To achieve our above-listed goals, we will make assumptions. Often, we assume the following: 1. Observations are independently and identically distributed (i.i.d) according to the joint distribution of the model. This reduces the computation of the conditional probability to the product of the individual probabilities of observations We don't always assume full independence. Sometimes, we assume only some level of independence between variables (e.g. var 3 depends on var 1 but not on var 2 ). 2. We observe all random variables in the domain on each observation (i.e. complete data, or fully observed model). We typically shade the nodes in a probabilistic graphical model to indicate they are observed. (Later we will work with unshaded nodes corresponding to missing data or latent variables.)","title":"Multiple observations, Complete IID data"},{"location":"lectures/week_2/#learning-parameters-for-a-distribution","text":"Lets take an example with discrete random variables . \\[ T: \\text{Temperature} ; t = \\text{\"hot\" or \"cold\"} \\] \\[ W: \\text{Weather} ; w = \\text{\"sunny\" or \"raining\"} \\] We know that \\[ P(T=h) = 0.40 \\] \\[ P(T=c) = 0.60 \\] \\[ P(W=s) = 0.70 \\] \\[ P(W=r) = 0.30 \\] and that these states define a valid probability distribution, so P(X) \\ge 0 ; \\sum_x P(x) = 1 P(X) \\ge 0 ; \\sum_x P(x) = 1 We could create a parameterized, probabilistic model, P(T, W) P(T, W) over the states \\[P(T | \\theta_T) ; \\theta_T = \\begin{bmatrix} 0.4 \\\\ 0.6 \\end{bmatrix}\\] \\[P(W | \\theta_W) ; \\theta_W = \\begin{bmatrix} 0.7 \\\\ 0.3 \\end{bmatrix}\\] Notice that \\theta_T \\theta_T and \\theta_W \\theta_W are the probability distributions of our random variables. Our parameters define the probability of the data explicitly and store it in a vector . We can represent the joint distribution P(T, W) P(T, W) , our model as: T W P h s 0.28 c r 0.18 h r 0.12 c s 0.42 from the joint distribution (which is again, essentially our model) we can compute the marginals \\[P(T=h) = \\sum_w P(T=h, W=w)\\] \\[ = 0.40\\] \\[P(T=c) = \\sum_w P(T=c, W=w)\\] \\[ = 0.60\\] \\[P(W=s) = \\sum_t P(W=s, T=t)\\] \\[ = 0.70\\] \\[P(W=r) = \\sum_t P(W=r, T=t)\\] \\[ = 0.30\\] and then we could ask questions about conditional probabilities, like P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66 P(W = s | T = c) = \\frac{P(s,c)}{P(T=c)} = \\frac{0.4}{0.6} = 0.66","title":"Learning Parameters for a Distribution"},{"location":"lectures/week_2/#why-did-we-do-this","text":"The whole point of the above example was to show that from a probabilistic model, which itself is just a joint distribution represented as a matrix (or tensor), we can compute both the marginal and conditional probabilities. This will allow us to compute probabilities, generate data and perform inference.","title":"Why did we do this?"},{"location":"lectures/week_2/#joint-dimensionality","text":"Lets take our previous example and expand on it. Firstly, it is helpful to think of the joint distribution grid with k^n k^n squares, where n n is our number of variables and k k our states. For our running example, this means our joint distribution is parameterized by a 4 dimensional vector, containing the probabilities of seeing any pair of states. We could of course, add more random variables to our model. Imagine we add B B , for whether or not we bike into work and H H , for overall health , each with two states. The dimensionality of our parameters then becomes k^n = 2^4 k^n = 2^4 . It is important to note that our joint distribution will be computed based on the assumptions we make about independence between variables. For example, we could assume that while T T and W W are independent from one another, H H is dependent on both T T and W W as well as B B . From the chain rule, we get P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B) P(T, H, B, W) = P(T)P(W)P(H|T, W)P(H|B)","title":"Joint Dimensionality"},{"location":"lectures/week_2/#likelihood-function","text":"So far, we have focused on the (log) probability function p(x|\\theta) p(x|\\theta) which assigns a probability (density) to any joint configuration of variables x x given fixed parameters \\theta \\theta . But our goal is to learn theta theta , which we do not start with and which is not fixed . This is the opposite of how we want to think. Really, we have some fixed data and we want to find parameters \\theta \\theta which maximize the likelihood of that data. Note We are asking \"given x x , how do I choose \\theta \\theta \". To do this, we define some function \\ell(\\theta ; x) = \\log p(x|\\theta) \\ell(\\theta ; x) = \\log p(x|\\theta) which we call the log likelihood function . Note The likelihood function is essentially a notational trick in order to make it easy to talk about our data as a function of our parameters. The process of learning is choosing \\theta \\theta to maximize some cost of loss function, L(\\theta) L(\\theta) which includes \\ell (\\theta) \\ell (\\theta) . This can be done in a couple of ways, including: Maximum likelihood estimation : L(\\theta) = \\ell (\\theta; \\mathcal D) L(\\theta) = \\ell (\\theta; \\mathcal D) Maximum a posteriori : L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta) L(\\theta) = \\ell (\\theta; \\mathcal D) + r(\\theta)","title":"Likelihood function"},{"location":"lectures/week_2/#maximum-likelihood-estimation","text":"The basic idea behind maximum likelihood estimation (MLE) is to pick values for our parameters which were most likely to have generated the data we saw \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) \\theta_{ML}^* = \\underset{\\theta}{\\operatorname{argmax}} \\ell(\\theta ; D) Note MLE is commonly used in statistics, and often leads to \"intuitive\", \"appealing\" or \"natural\" estimators. For IID data \\[p(\\mathcal D | \\theta) = \\prod_m p(x^{(m)} | \\theta)\\] \\[\\ell (\\theta ; D | \\theta) = \\sum_m log p(x^{(m)} | \\theta)\\] Note The IDD assumption turns the log likelihood into a sum, making the derivative easy to compute.","title":"Maximum likelihood estimation"},{"location":"lectures/week_2/#sufficient-statistics","text":"A statistic is a (possibly vector valued) deterministic function of a (set of) random variable(s). A sufficient statistic is a statistic that conveys exactly the same information about the data generating process that created that data as the entire data itself. In other words, once we know the sufficient statistic, T(x) T(x) , then our inferences are the same as would be obtained from our entire data. More formally, we say that T(X) T(X) is a sufficient statistic for X X if T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta T(x^{(1)}) = T(x^{(2)}) \\Rightarrow L(\\theta ; x^{(1)}) = L(\\theta; x^{(2)}) \\forall \\theta Put another way P(\\theta | T(X)) = P(\\theta | X) P(\\theta | T(X)) = P(\\theta | X) Note Why is the useful? Well, if we have a particular large data sample, a lot of the data may be redundant. If we knew the sufficient statistic for that sample, we could use it in place of the full data sample. Equivalently (by the Neyman factorization theorem) we can write P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) P(\\theta | T(X)) = h(x, T(x))g(T(x), \\theta) An example is the exponential family p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\} p(x | \\eta) = h(x)\\exp\\{\\eta^TT(x)-A(\\eta)\\}","title":"Sufficient statistics"},{"location":"lectures/week_2/#sufficient-statistics-example-bernoulli-trials","text":"","title":"Sufficient statistics example: Bernoulli Trials"},{"location":"tutorials/week_1/","text":"","title":"Week 1"}]}